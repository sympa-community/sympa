#!--PERL--
# -*- indent-tabs-mode: nil; -*-
# vim:ft=perl:et:sw=4
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
#
# Copyright (c) 1997, 1998, 1999 Institut Pasteur & Christophe Wolfhugel
# Copyright (c) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
# 2006, 2007, 2008, 2009, 2010, 2011 Comite Reseau des Universites
# Copyright (c) 2011, 2012, 2013, 2014 GIP RENATER
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use lib split(/:/, $ENV{SYMPALIB} || ''), '--modulesdir--';
use strict;
use warnings;
use File::Copy qw();
use Getopt::Long;
use MIME::Charset;
use Pod::Usage;
use POSIX qw();

use admin;
use Bulk;
use Commands;
use Conf;
use Config_XML;
use Sympa::Constants;
use Sympa::Crash;    # Show traceback.
use Family;
use Sympa::Language;
use List;
use Log;
use mail;
use Message;
use Sympa::Regexps;
use report;
use SDM;
use tools;
use Upgrade;

# dirty global variables
my $is_signed = {};

## Internal tuning
# delay between each read of the digestqueue
my $digestsleep = 5;

## Init random engine
srand(time());

my $daemon_name = Log::set_daemon($0);
my $ip;
$ip = $ENV{'REMOTE_HOST'};
$ip = $ENV{'REMOTE_ADDR'} unless ($ip);

## Check --dump option
my %options;
unless (
    GetOptions(
        \%main::options,        'dump=s',
        'debug|d',              'log_level=s',
        'foreground',           'config|f=s',
        'lang|l=s',             'mail|m',
        'keepcopy|k=s',         'help|h',
        'version|v',            'import=s',
        'make_alias_file',      'lowercase',
        'sync_list_db',         'md5_encode_password',
        'close_list=s',         'rename_list=s',
        'new_listname=s',       'new_listrobot=s',
        'purge_list=s',         'create_list',
        'instantiate_family=s', 'robot=s',
        'add_list=s',           'modify_list=s',
        'close_family=s',       'md5_digest=s',
        'change_user_email',    'current_email=s',
        'new_email=s',          'input_file=s',
        'sync_include=s',       'upgrade',
        'upgrade_shared',       'from=s',
        'to=s',                 'reload_list_config',
        'list=s',               'quiet',
        'close_unknown',        'test_database_message_buffer',
        'conf_2_db',            'export_list',
        'health_check',         'service=s',
    )
    ) {
    pod2usage(-exitval => 1, -output => \*STDERR);
}

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless ($main::options{'log_level'});
}
## Batch mode, ie NOT daemon
$main::options{'batch'} = 1
    if $main::options{'dump'}
        || $main::options{'import'}
        || $main::options{'make_alias_file'}
        || $main::options{'lowercase'}
        || $main::options{'md5_encode_password'}
        || $main::options{'change_user_email'}
        || $main::options{'close_list'}
        || $main::options{'purge_list'}
        || $main::options{'create_list'}
        || $main::options{'rename_list'}
        || $main::options{'instantiate_family'}
        || $main::options{'add_list'}
        || $main::options{'modify_list'}
        || $main::options{'close_family'}
        || $main::options{'md5_digest'}
        || $main::options{'sync_include'}
        || $main::options{'upgrade'}
        || $main::options{'upgrade_shared'}
        || $main::options{'test_database_message_buffer'}
        || $main::options{'conf_2_db'}
        || $main::options{'reload_list_config'}
        || $main::options{'sync_list_db'}
        || $main::options{'export_list'}
        || $main::options{'health_check'};

# Some option force foreground mode
$main::options{'foreground'} = 1
    if ($main::options{'debug'} || $main::options{'batch'});

$main::options{'log_to_stderr'} = 1 unless ($main::options{'batch'});
$main::options{'log_to_stderr'} = 1
    if ($main::options{'upgrade'}
    || $main::options{'reload_list_config'}
    || $main::options{'test_database_message_buffer'}
    || $main::options{'conf_2_db'});

if ($main::options{'help'}) {
    pod2usage(0);
} elsif ($main::options{'version'}) {
    printf "Sympa %s\n", Sympa::Constants::VERSION;
    exit 0;
} elsif ($main::options{'health_check'}) {
    ## Health check

    ## Load configuration file. Ignoring database config for now: it avoids
    ## trying to load a database that could not exist yet.
    unless (Conf::load(Conf::get_sympa_conf(), 'no_db')) {
        #FIXME: force reload
        printf STDERR
            "Configuration file %s has errors.\n",
            Conf::get_sympa_conf();
        exit 1;
    }

    ## Open the syslog and say we're read out stuff.
    Log::do_openlog($Conf::Conf{'syslog'}, $Conf::Conf{'log_socket_type'},
        'health_check');

    ## Setting log_level using conf unless it is set by calling option
    if ($main::options{'log_level'}) {
        Log::set_log_level($main::options{'log_level'});
        Log::do_log(
            'info',
            'Configuration file read, log level set using options: %s',
            $main::options{'log_level'}
        );
    } else {
        Log::set_log_level($Conf::Conf{'log_level'});
        Log::do_log(
            'info',
            'Configuration file read, default log level %s',
            $Conf::Conf{'log_level'}
        );
    }

    ## Check database connectivity and probe database
    unless (SDM::check_db_connect('just_try') and SDM::probe_db()) {
        printf STDERR
            "Database %s defined in sympa.conf has not the right structure or is unreachable. verify db_xxx parameters in sympa.conf\n",
            $Conf::Conf{'db_name'};
        exit 1;
    }

    ## Now trying to load full config (including database)
    unless (Conf::load()) {    #FIXME: load Site, then robot cache
        printf STDERR
            "Unable to load Sympa configuration, file %s or any of the virtual host robot.conf files contain errors. Exiting.\n",
            Conf::get_sympa_conf();
        exit 1;
    }

    ## Change working directory.
    if (!chdir($Conf::Conf{'home'})) {
        printf STDERR "Can't chdir to %s: %s\n", $Conf::Conf{'home'}, $!;
        exit 1;
    }

    ## Check for several files.
    unless (Conf::checkfiles_as_root()) {
        printf STDERR "Missing files.\n";
        exit 1;
    }

    ## Check that the data structure is uptodate
    unless (SDM::data_structure_uptodate()) {
        printf STDERR
            "Data structure was not updated; you should run sympa.pl --upgrade to run the upgrade process.\n";
        exit 1;
    }

    exit 0;
}

## Main loop

my %loop_info;
my %msgid_table;
my $latest_msgid_table_cleanup = time;
my $default_lang;

# this loop is run foreach HUP signal received
my $signal = 0;

local $main::daemon_usage;

my $language = Sympa::Language->instance;

while ($signal ne 'term') {    #as long as a signal is not received }
    ## Load sympa.conf.
    unless (Conf::load(Conf::get_sympa_conf())) {    #Site and Robot
        printf STDERR
            "Unable to load sympa configuration, file %s or one of the vhost robot.conf files contain errors. Exiting.\n",
            Conf::get_sympa_conf();
        exit 1;
    }

    ## Open the syslog and say we're read out stuff.
    Log::do_openlog($Conf::Conf{'syslog'}, $Conf::Conf{'log_socket_type'},
        'sympa');

    # Enable SMTP logging if required
    $mail::log_smtp = $main::options{'mail'}
        || tools::smart_eq($Conf::Conf{'log_smtp'}, 'on');

    # setting log_level using conf unless it is set by calling option
    if (defined $main::options{'log_level'}) {
        Log::set_log_level($main::options{'log_level'});
        Log::do_log(
            'info',
            'Configuration file read, log level set using options: %s',
            $main::options{'log_level'}
        );
    } else {
        Log::set_log_level($Conf::Conf{'log_level'});
        Log::do_log(
            'info',
            'Configuration file read, default log level %s',
            $Conf::Conf{'log_level'}
        );
    }

    tools::ciphersaber_installed();

    if (tools::cookie_changed($Conf::Conf{'cookie'})) {
        Log::fatal_err(
            'sympa.conf/cookie parameter has changed. You may have severe inconsitencies into password storage. Restore previous cookie or write some tool to re-encrypt password in database and check spools contents (look at %s/cookies.history file)',
            $Conf::Conf{'etc'}
        );
    }

    ## Set locale configuration
    ## Compatibility with version < 2.3.3
    $main::options{'lang'} =~ s/\.cat$//
        if defined $main::options{'lang'};
    $default_lang =
        $language->set_lang($main::options{'lang'}, $Conf::Conf{'lang'},
        'en');

    ## Main program
    if (!chdir($Conf::Conf{'home'})) {
        die sprintf 'Can\'t chdir to %s: %s', $Conf::Conf{'home'}, $!;
        ## Function never returns.
    }

    if (tools::smart_eq($main::options{'service'}, 'process_message')) {
        $main::daemon_usage = Conf::DAEMON_MESSAGE;
    } elsif (tools::smart_eq($main::options{'service'}, 'process_command')) {
        $main::daemon_usage = Conf::DAEMON_COMMAND;
    } elsif (tools::smart_eq($main::options{'service'}, 'process_creation')) {
        $main::daemon_usage = Conf::DAEMON_CREATION;
    } else {
        # default is to run one sympa.pl server for commands, messages and
        # automatic lists creation.
        $main::daemon_usage = Conf::DAEMON_ALL;
    }

    ## Check for several files.
    unless (Conf::checkfiles_as_root()) {
        Log::fatal_err('Missing files');
        ## No return.
    }

    if ($signal ne 'hup') {
        ## Put ourselves in background if we're not in debug mode. That method
        ## works on many systems, although, it seems that Unix conceptors have
        ## decided that there won't be a single and easy way to detach a
        ## process from its controlling TTY.
        unless ($main::options{'foreground'}) {
            if (open(TTY, "/dev/tty")) {
                ioctl(TTY, 0x20007471, 0);    # XXX s/b TIOCNOTTY()
                close(TTY);
            }
            open(STDIN,  ">> /dev/null");
            open(STDOUT, ">> /dev/null");
            open(STDERR, ">> /dev/null");

            setpgrp(0, 0);
            # start the main sympa.pl daemon

            ## Fork a new process dedicated to automatic list creation, if
            ## required
            if (($Conf::Conf{'automatic_list_feature'} eq 'on')
                || $main::daemon_usage == Conf::DAEMON_CREATION) {
                Log::do_log('debug',
                    "Starting server for automatic lists creation");
                if ((my $child_pid = fork) != 0) {
                    Log::do_log('notice',
                        "Server for automatic lists creation started, pid $child_pid"
                    );
                    Log::do_log('debug',
                        "Server for automatic lists creation started, pid $child_pid, exiting from initial process"
                    );
                } else {
                    ## We're in the specialized child process
                    $main::daemon_usage =
                        Conf::DAEMON_CREATION;    # automatic lists creation
                }
            }

            unless ($main::daemon_usage == Conf::DAEMON_CREATION) {

                ## A single process that handles both messages and commands
                ## The distribute/ spool is not used
                if (   $Conf::Conf{'distribution_mode'} eq 'single'
                    && $main::daemon_usage == Conf::DAEMON_ALL) {
                    my $purpose = 'all';
                    Log::do_log('debug', 'Starting server for %s purpose',
                        $purpose);
                    if ((my $child_pid = fork) != 0) {
                        Log::do_log('info', 'Server started for %s, PID %s',
                            $purpose, $child_pid);
                        Log::do_log('debug',
                            "$purpose server started, pid $child_pid, exiting from initial process"
                        );
                        exit(0);
                    }

                    ## Starting a dedicated process if sympa.pl is started
                    ## with a --service argument
                } elsif ($main::daemon_usage == Conf::DAEMON_COMMAND
                    || $main::daemon_usage == Conf::DAEMON_COMMAND) {

                    my $purpose;
                    if ($main::daemon_usage == Conf::DAEMON_COMMAND) {
                        $purpose = 'command';
                    } elsif ($main::daemon_usage == Conf::DAEMON_MESSAGE) {
                        $purpose = 'message';
                    }
                    Log::do_log('debug', 'Starting server for %s purpose',
                        $purpose);
                    if ((my $child_pid = fork) != 0) {
                        Log::do_log('info', 'Server started for %s, PID %s',
                            $purpose, $child_pid);
                        Log::do_log('debug',
                            "$purpose server started, pid $child_pid, exiting from initial process"
                        );
                        exit(0);
                    }

                    ## Sympa forks to have 2 dedicated processes for
                    ## processing commands and messages
                } else {
                    # fork sympa.pl dedicated to commands
                    $main::daemon_usage = Conf::DAEMON_COMMAND;
                    Log::do_log('debug', "Starting server for commands");
                    if ((my $child_pid = fork) != 0) {
                        Log::do_log('info',
                            'Server for commands started, PID %s',
                            $child_pid);
                        # main process continue in order to fork
                        $main::daemon_usage = Conf::DAEMON_MESSAGE;
                        Log::do_log('debug', "Starting server for messages");
                        if ((my $child_pid = fork) != 0) {
                            Log::do_log('notice',
                                "Server for messages started, pid $child_pid"
                            );
                            Log::do_log('debug',
                                "Server for messages started, pid $child_pid, exiting from initial process"
                            );
                            exit(0);    # exit from main process
                        }
                    }
                }
            }
        }

        my $service = 'sympa';
        $service .= '(distribute)'
            if ($main::daemon_usage == Conf::DAEMON_MESSAGE);
        $service .= '(command)'
            if ($main::daemon_usage == Conf::DAEMON_COMMAND);
        $service .= '(creation)'
            if ($main::daemon_usage == Conf::DAEMON_CREATION);
        Log::do_openlog($Conf::Conf{'syslog'}, $Conf::Conf{'log_socket_type'},
            $service);

        Log::do_log('debug', 'Running server %s for %s purpose', $$,
            $service);
        unless ($main::options{'batch'}) {

            ## Create and write the PID file
            my $file = 'sympa';
            $file = 'sympa-distribute'
                if $main::daemon_usage == Conf::DAEMON_MESSAGE;
            $file = 'sympa-creation'
                if $main::daemon_usage == Conf::DAEMON_CREATION;

            ## If process is running in foreground, don't write STDERR to a
            ## dedicated file
            my $options;
            $options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});
            tools::write_pid($file, $$, $options);
            unless ($options->{'stderr_to_tty'}) {
                tools::direct_stderr_to_file(('pid' => $$));
            }
        }

        # Set the User ID & Group ID for the process
        $( = $) = (getgrnam(Sympa::Constants::GROUP))[2];
        $< = $> = (getpwnam(Sympa::Constants::USER))[2];

        ## Required on FreeBSD to change ALL IDs
        ## (effective UID + real UID + saved UID)
        POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
        POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

        ## Check if the UID has correctly been set (useful on OS X)
        unless (($( == (getgrnam(Sympa::Constants::GROUP))[2])
            && ($< == (getpwnam(Sympa::Constants::USER))[2])) {
            Log::fatal_err(
                "Failed to change process user ID and group ID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via sudo."
            );
        }

        # Sets the UMASK
        umask(oct($Conf::Conf{'umask'}));

        ## Most initializations have now been done.
        Log::do_log('notice', "Sympa %s started", Sympa::Constants::VERSION);
    } else {
        Log::do_log('notice', "Sympa %s reload config",
            Sympa::Constants::VERSION);
        $signal = '0';
    }

## Check for several files.
## Prevent that 2 processes perform checks at the same time...
    if (   $main::daemon_usage == Conf::DAEMON_COMMAND
        || $main::daemon_usage == Conf::DAEMON_ALL) {
        unless (Conf::checkfiles()) {
            Log::fatal_err('Missing files');
            ## No return.
        }
    } else {
        sleep 1;   ## wait until main process has created required directories
    }

## Daemon called for dumping subscribers list
    if ($main::options{'dump'}) {

        my ($all_lists, $list);
        if ($main::options{'dump'} eq 'ALL') {
            $all_lists = List::get_lists('*');
        } else {

            ## The parameter can be a list address
            unless ($main::options{'dump'} =~ /\@/) {
                Log::do_log('err', 'Incorrect list address %s',
                    $main::options{'dump'});

                exit;
            }

            my $list = List->new($main::options{'dump'});
            unless (defined $list) {
                Log::do_log('err', 'Unknown list %s', $main::options{'dump'});

                exit;
            }
            push @$all_lists, $list;
        }

        foreach my $list (@$all_lists) {
            unless ($list->dump()) {
                print STDERR "Could not dump list(s)\n";
            }
        }

        exit 0;
    } elsif ($main::options{'make_alias_file'}) {
        my $robots = $main::options{'robot'} || '*';
        my @robots;
        if ($robots eq '*') {
            @robots = List::get_robots();
        } else {
            @robots = grep { length $_ } split(/[\s,]+/, $robots);
        }
        exit 0 unless @robots;

        # There may be multiple aliases files.  Give each of them suffixed
        # name.
        my ($basename, %robots_of, %sympa_aliases);
        $basename = sprintf '%s/sympa_aliases.%s', $Conf::Conf{'tmpdir'}, $$;

        foreach my $robot (@robots) {
            my $file = Conf::get_robot_conf($robot, 'sendmail_aliases');
            $robots_of{$file} ||= [];
            push @{$robots_of{$file}}, $robot;
        }
        if (1 < scalar(keys %robots_of)) {
            my $i = 0;
            %sympa_aliases = map {
                $i++;
                map { $_ => sprintf('%s.%03d', $basename, $i) }
                    @{$robots_of{$_}}
            } sort keys %robots_of;
        } else {
            %sympa_aliases = map { $_ => $basename } @robots;
        }

        # Create files.
        foreach my $sympa_aliases (values %sympa_aliases) {
            my $fh;
            unless (open $fh, '>', $sympa_aliases) {    # truncate if exists
                printf STDERR "Unable to create %s: %s\n", $sympa_aliases, $!;
                exit 1;
            }
            close $fh;
        }

        # Write files.
        foreach my $robot (sort @robots) {
            my $all_lists     = List::get_lists($robot);
            my $alias_manager = Conf::get_robot_conf($robot, 'alias_manager');
            my $sympa_aliases = $sympa_aliases{$robot};

            my $fh;
            unless (open $fh, '>>', $sympa_aliases) {    # append
                printf STDERR "Unable to create %s: %s\n", $sympa_aliases, $!;
                exit 1;
            }
            printf $fh "#\n#\tAliases for all Sympa lists open on %s\n#\n",
                $robot;
            close $fh;
            foreach my $list (@{$all_lists || []}) {
                next unless $list->{'admin'}{'status'} eq 'open';

                system($alias_manager, 'add', $list->{'name'},
                    $list->{'domain'}, $sympa_aliases);
            }
        }

        if (1 < scalar(keys %robots_of)) {
            printf
                "Sympa aliases files %s.??? were made.  You probably need to install them in your SMTP engine.\n",
                $basename;
        } else {
            printf
                "Sympa aliases file %s was made.  You probably need to install it in your SMTP engine.\n",
                $basename;
        }
        exit 0;
    } elsif ($main::options{'md5_digest'}) {
        my $md5 = tools::md5_fingerprint($main::options{'md5_digest'});
        printf "md5 digest : $md5 \n";

        exit 0;
    } elsif ($main::options{'import'}) {
        my ($list, $total);

        ## The parameter should be a list address
        unless ($main::options{'import'} =~ /\@/) {
            Log::do_log(
                'err',
                'Incorrect list address %s',
                $main::options{'import'}
            );
            exit;
        }

        unless ($list = List->new($main::options{'import'})) {
            Log::fatal_err('Unknown list name %s', $main::options{'import'});
        }

        ## Read imported data from STDIN
        while (<STDIN>) {
            next if /^\s*$/;
            next if /^\s*\#/;

            unless (/^\s*((\S+|\".*\")@\S+)(\s*(\S.*))?\s*$/) {
                printf STDERR "Not an email address: %s\n", $_;
            }

            my $email = lc($1);
            my $gecos = $4;
            my $u;
            my $defaults = $list->get_default_user_options();
            %{$u} = %{$defaults};
            $u->{'email'} = $email;
            $u->{'gecos'} = $gecos;

            $list->add_list_member($u);
            if (defined $list->{'add_outcome'}{'errors'}) {
                printf STDERR "\nCould not add %s. %s\n", $email,
                    $list->{'add_outcome'}{'errors'}{'error_message'};
                next;
            }
            print STDERR '+';

            $total++;
        }

        printf STDERR "Total imported subscribers: %d\n", $total;

        exit 0;
    } elsif ($main::options{'md5_encode_password'}) {

        unless ($List::use_db) {
            Log::fatal_err(
                "You don't have a database setup, can't lowercase email addresses"
            );
        }

        my $total = Upgrade::md5_encode_password();
        printf STDERR "Total password re-encoded using md5: %d\n", $total;

        exit 0;

    } elsif ($main::options{'lowercase'}) {

        unless ($List::use_db) {
            Log::fatal_err(
                "You don't have a database setup, can't lowercase email addresses"
            );
        }

        print STDERR "Working on user_table...\n";
        my $total = List::lowercase_field('user_table', 'email_user');

        print STDERR "Working on subscriber_table...\n";
        $total +=
            List::lowercase_field('subscriber_table', 'user_subscriber');

        unless (defined $total) {
            Log::fatal_err("Could not work on dabatase");
        }

        printf STDERR "Total lowercased rows: %d\n", $total;

        exit 0;
    } elsif ($main::options{'close_list'}) {

        my ($listname, $robotname) = split /\@/, $main::options{'close_list'};
        my $list = List->new($listname, $robotname);

        unless (defined $list) {
            print STDERR "Incorrect list name $main::options{'close_list'}\n";
            exit 1;
        }

        if ($list->{'admin'}{'family_name'}) {
            unless (
                $list->set_status_family_closed(
                    'close_list', $list->{'name'}
                )
                ) {
                print STDERR
                    "Could not close list $main::options{'close_list'}\n";
                exit 1;
            }
        } else {
            unless ($list->close_list()) {
                print STDERR
                    "Could not close list $main::options{'close_list'}\n";
                exit 1;
            }
        }

        printf STDOUT "List %s has been closed, aliases have been removed\n",
            $list->{'name'};

        exit 0;
    } elsif ($main::options{'change_user_email'}) {

        unless ($main::options{'current_email'}
            && $main::options{'new_email'}) {
            print STDERR "Missing current_email or new_email parameter\n";
            exit 1;
        }

        foreach my $robot (keys %{$Conf::Conf{'robots'}}) {

            printf STDOUT "Doing processing for virtual robot %s...\n",
                $robot;
            my ($status, $failed_for) = admin::change_user_email(
                current_email => $main::options{'current_email'},
                new_email     => $main::options{'new_email'},
                robot         => $robot
            );
            unless (defined $status) {
                printf STDERR
                    "Failed to change user email address in virtual robot %s'}\n",
                    $robot;
                exit 1;
            }

            foreach my $failed_list (@$failed_for) {
                printf STDERR
                    "Failed to change user email address for list %s'}\n",
                    $failed_list->{'name'};
            }
        }

        printf STDOUT "Email address %s has been changed to %s\n",
            $main::options{'current_email'}, $main::options{'new_email'};

        exit 0;
    } elsif ($main::options{'purge_list'}) {

        my ($listname, $robotname) = split /\@/, $main::options{'purge_list'};
        my $list = List->new($listname, $robotname);

        unless (defined $list) {
            print STDERR "Incorrect list name $main::options{'purge_list'}\n";
            exit 1;
        }

        if ($list->{'admin'}{'family_name'}) {
            unless (
                $list->set_status_family_closed(
                    'purge_list', $list->{'name'}
                )
                ) {
                print STDERR
                    "Could not purge list $main::options{'purge_list'}\n";
                exit 1;
            }
        } else {
            unless ($list->purge()) {
                print STDERR
                    "Could not purge list $main::options{'close_list'}\n";
                exit 1;
            }
        }

        printf STDOUT "List %s has been closed, aliases have been removed\n",
            $list->{'name'};

        exit 0;
    } elsif ($main::options{'rename_list'}) {

        ## TODO A completer

        my ($listname, $robotname) = split /\@/,
            $main::options{'rename_list'};
        my $list = List->new($listname, $robotname);

        unless (defined $list) {
            print STDERR
                "Incorrect list name $main::options{'rename_list'}\n";
            exit 1;
        }

        unless ($main::options{'new_listname'}) {
            print STDERR "Missing parameter new_listname\n";
            exit 1;
        }

        unless ($main::options{'new_listrobot'}) {
            print STDERR "Missing parameter new_listrobot\n";
            exit 1;
        }

        my ($new_listname, $new_robotname) =
            ($main::options{'new_listname'}, $main::options{'new_listrobot'});

        my $result = admin::rename_list(
            list         => $list,
            new_listname => $new_listname,
            new_robot    => $new_robotname,
            options      => {'skip_authz' => 1},
            user_email   => 'listmaster@' . $robotname,
        );

        unless ($result == 1) {
            printf STDERR "Could not rename list %s to %s: %s\@%s\n",
                $main::options{'rename_list'}, $main::options{'new_listname'},
                $main::options{'new_listrobot'}, $result;
            exit 1;
        }

        printf STDOUT "List %s has been renamed to %s\@%s\n",
            $main::options{'rename_list'}, $main::options{'new_listname'},
            $main::options{'new_listrobot'};

        exit 0;

    } elsif ($main::options{'test_database_message_buffer'}) {
        my $size = 0;
        printf
            "Sympa is going to store messages bigger and bigger to test the limit with its database. This may be very long \n";
        ## will test message until a 21 Mo message.
        $size = Bulk::store_test(21000);
        if ($size == 21000) {
            printf
                "The maximum message size ($size Ko) testing was successful \n";
        } else {
            printf
                "maximun message size that can be stored in database : $size Ko\n";
        }
        exit 1;

    } elsif ($main::options{'conf_2_db'}) {

        printf
            "Sympa is going to store %s in database conf_table. This operation do NOT remove original files\n",
            Conf::get_sympa_conf();
        if (Conf::conf_2_db()) {
            printf "Done";
        } else {
            printf "an error occur";
        }
        exit 1;

    } elsif ($main::options{'create_list'}) {
        my $robot = $main::options{'robot'} || $Conf::Conf{'host'};

        unless ($main::options{'input_file'}) {
            print STDERR "Error : missing 'input_file' parameter\n";
            exit 1;
        }

        unless (open INFILE, $main::options{'input_file'}) {
            print STDERR "Unable to open $main::options{'input_file'}) file";
            exit 1;
        }

        my $config = Config_XML->new(\*INFILE);
        unless (defined $config->createHash()) {
            print STDERR "Error in representation data with these xml data\n";
            exit 1;
        }

        my $hash = $config->getHash();

        close INFILE;

        my $resul =
            admin::create_list_old($hash->{'config'}, $hash->{'type'}, $robot,
            "command_line");
        unless (defined $resul) {
            print STDERR "Could not create list with these xml data\n";
            exit 1;
        }

        if (!defined($resul->{'aliases'}) || $resul->{'aliases'} == 1) {
            printf STDOUT "List has been created \n";
            exit 0;
        } else {
            printf STDOUT
                "List has been created, required aliases :\n $resul->{'aliases'} \n";
            exit 0;
        }
    } elsif ($main::options{'instantiate_family'}) {

        my $robot = $main::options{'robot'} || $Conf::Conf{'host'};

        my $family_name;
        unless ($family_name = $main::options{'instantiate_family'}) {
            print STDERR "Error : missing family parameter\n";
            exit 1;
        }
        my $family;
        unless ($family = Family->new($family_name, $robot)) {
            print STDERR
                "The family $family_name does not exist, impossible instantiation\n";
            exit 1;
        }

        unless ($main::options{'input_file'}) {
            print STDERR "Error : missing input_file parameter\n";
            exit 1;
        }

        unless (-r $main::options{'input_file'}) {
            print STDERR "Unable to read $main::options{'input_file'} file";
            exit 1;
        }

        unless (
            $family->instantiate(
                $main::options{'input_file'},
                $main::options{'close_unknown'}
            )
            ) {
            print STDERR
                "\nImpossible family instantiation : action stopped \n";
            exit 1;
        }

        my %result;
        my $err = $family->get_instantiation_results(\%result);
        close INFILE;

        unless ($main::options{'quiet'}) {
            print STDOUT "@{$result{'info'}}";
            print STDOUT "@{$result{'warn'}}";
        }
        if ($err) {
            print STDERR "@{$result{'errors'}}";
        }

        exit 0;
    } elsif ($main::options{'add_list'}) {

        my $robot = $main::options{'robot'} || $Conf::Conf{'host'};

        my $family_name;
        unless ($family_name = $main::options{'add_list'}) {
            print STDERR "Error : missing family parameter\n";
            exit 1;
        }

        print STDOUT
            "\n************************************************************\n";

        my $family;
        unless ($family = Family->new($family_name, $robot)) {
            print STDERR
                "The family $family_name does not exist, impossible to add a list\n";
            exit 1;
        }

        unless ($main::options{'input_file'}) {
            print STDERR "Error : missing 'input_file' parameter\n";
            exit 1;
        }

        unless (open INFILE, $main::options{'input_file'}) {
            print STDERR "\n Impossible to open input file  : $! \n";
            exit 1;
        }

        my $result;
        unless ($result = $family->add_list(\*INFILE)) {
            print STDERR
                "\nImpossible to add a list to the family : action stopped \n";
            exit 1;
        }

        print STDOUT
            "\n************************************************************\n";

        unless (defined $result->{'ok'}) {
            printf STDERR "\n%s\n", join("\n", @{$result->{'string_info'}});
            print STDERR
                "\n The action has been stopped because of error :\n";
            printf STDERR "\n%s\n", join("\n", @{$result->{'string_error'}});
            exit 1;
        }

        close INFILE;

        print STDOUT "\n%s\n", join("\n", @{$result->{'string_info'}});
        exit 0;
    } elsif ($main::options{'sync_include'}) {

        my $list = List->new($main::options{'sync_include'});

        unless (defined $list) {
            print STDERR
                "Incorrect list name $main::options{'sync_include'}\n";
            exit 1;
        }

        unless (defined $list->sync_include()) {
            print STDERR "Failed to synchronize list members\n";
            exit 1;
        }

        printf "Members of list %s have been successfully update.\n",
            $list->get_list_address();
        exit 0;
## Migration from one version to another
    } elsif ($main::options{'upgrade'}) {

        Log::do_log('notice', "Upgrade process...");

        $main::options{'from'} ||= Upgrade::get_previous_version();
        $main::options{'to'}   ||= Sympa::Constants::VERSION;

        if ($main::options{'from'} eq $main::options{'to'}) {
            Log::do_log('err', 'Current version: %s; no upgrade is required',
                $main::options{'to'});
            exit 0;
        } else {
            Log::do_log('notice', "Upgrading from %s to %s...",
                $main::options{'from'}, $main::options{'to'});
        }

        unless (
            Upgrade::upgrade($main::options{'from'}, $main::options{'to'})) {
            Log::do_log('err', "Migration from %s to %s failed",
                $main::options{'from'}, $main::options{'to'});
            exit 1;
        }

        Log::do_log('notice', 'Upgrade process finished');
        Upgrade::update_version();

        exit 0;

## rename file names that may be incorrectly encoded because of previous Sympa
## versions
    } elsif ($main::options{'upgrade_shared'}) {

        Log::do_log('notice', "Upgrade shared process...");

        my $listname;
        my $robot;

        unless (($main::options{'list'}) || ($main::options{'robot'})) {
            Log::do_log('err',
                "listname and domain are required, use --list= --robot= options"
            );
            exit 0;
        }
        $listname = $main::options{'list'};
        $robot    = $main::options{'robot'};

        Log::do_log('notice', "Upgrading share for list=%s robot=%s",
            $listname, $robot);

        my $list = List->new($listname, $robot);

        unless (defined $list) {
            printf STDERR "Incorrect list or domain name : %s %s\n",
                $listname, $robot;
            exit 1;
        }

        if (-d $list->{'dir'} . '/shared') {
            Log::do_log(
                'notice',
                'Processing list %s...',
                $list->get_list_address()
            );

            ## Determine default lang for this list
            ## It should tell us what character encoding was used for
            ## filenames
            $language->set_lang(
                $list->{'admin'}{'lang'},
                Conf::get_robot_conf($robot, 'lang'),
                $default_lang
            );
            my $list_encoding = tools::lang2charset($language->get_lang);

            my $count = tools::qencode_hierarchy($list->{'dir'} . '/shared',
                $list_encoding);

            if ($count) {
                Log::do_log('notice',
                    'List %s: %d filenames has been changed',
                    $list->{'name'}, $count);
            }
        }
        Log::do_log('notice', 'Upgrade_shared process finished');

        exit 0;

    } elsif ($main::options{'reload_list_config'}) {

        if ($main::options{'list'}) {

            Log::do_log('notice', 'Loading list %s...',
                $main::options{'list'});
            my $list =
                List->new($main::options{'list'}, '', {'reload_config' => 1});
            unless (defined $list) {
                print STDERR
                    "Error : incorrect list name '$main::options{'list'}'\n";
                exit 1;
            }
        } else {
            Log::do_log('notice', "Loading ALL lists...");
            my $all_lists = List::get_lists('*', {'reload_config' => 1});
        }

        exit 0;
    }

##########################################
    elsif ($main::options{'modify_list'}) {

        my $robot = $main::options{'robot'} || $Conf::Conf{'host'};

        my $family_name;
        unless ($family_name = $main::options{'modify_list'}) {
            print STDERR "Error : missing family parameter\n";
            exit 1;
        }

        print STDOUT
            "\n************************************************************\n";

        my $family;
        unless ($family = Family->new($family_name, $robot)) {
            print STDERR
                "The family $family_name does not exist, impossible to modify the list.\n";
            exit 1;
        }

        unless ($main::options{'input_file'}) {
            print STDERR "Error : missing input_file parameter\n";
            exit 1;
        }

        unless (open INFILE, $main::options{'input_file'}) {
            print STDERR "Unable to open $main::options{'input_file'}) file";
            exit 1;
        }

        my $result;
        unless ($result = $family->modify_list(\*INFILE)) {
            print STDERR
                "\nImpossible to modify the family list : action stopped. \n";
            exit 1;
        }

        print STDOUT
            "\n************************************************************\n";

        unless (defined $result->{'ok'}) {
            printf STDERR "\n%s\n", join("\n", @{$result->{'string_info'}});
            print STDERR "\nThe action has been stopped because of error :\n";
            printf STDERR "\n%s\n", join("\n", @{$result->{'string_error'}});
            exit 1;
        }

        close INFILE;

        printf STDOUT "\n%s\n", join("\n", @{$result->{'string_info'}});
        exit 0;
    }

##########################################
    elsif ($main::options{'close_family'}) {

        my $robot = $main::options{'robot'} || $Conf::Conf{'host'};

        my $family_name;
        unless ($family_name = $main::options{'close_family'}) {
            pod2usage(-exitval => 1, -output => \*STDERR);
        }
        my $family;
        unless ($family = Family->new($family_name, $robot)) {
            print STDERR
                "The family $family_name does not exist, impossible family closure\n";
            exit 1;
        }

        my $string;
        unless ($string = $family->close_family()) {
            print STDERR "\nImpossible family closure : action stopped \n";
            exit 1;
        }

        print STDOUT $string;
        exit 0;
    }
##########################################
    elsif ($main::options{'sync_list_db'}) {
        unless ($Conf::Conf{'db_list_cache'} eq 'on') {
            print STDOUT
                "\nSympa not configured to use database list caching \n";
            exit 1;
        }
        my $listname = $main::options{'list'} || '';
        if (length($listname) > 1) {
            my $list = List->new($listname);
            unless (defined $list) {
                print STDOUT "\nList '$listname' does not exist. \n";
                exit 1;
            }
            $list->_update_list_db;
        } else {
            List::_flush_list_db();
            my $all_lists = List::get_lists('*', {'use_files' => 1});
            foreach my $list (@$all_lists) {
                $list->_update_list_db;
            }
        }
        exit 0;
    } elsif ($main::options{'export_list'}) {
        my $robot_id = $main::options{'robot'} || '*';
        my $all_lists = List::get_lists($robot_id);
        exit 1 unless defined $all_lists;
        foreach my $list (@$all_lists) {
            printf "%s\n", $list->{'name'};
        }
        exit 0;
    }

## Do we have right access in the directory
    if ($main::options{'keepcopy'}) {
        if (!-d $main::options{'keepcopy'}) {
            Log::do_log(
                'notice',
                'Cannot keep a copy of incoming messages: %s is not a directory',
                $main::options{'keepcopy'}
            );
            delete $main::options{'keepcopy'};
        } elsif (!-w $main::options{'keepcopy'}) {
            Log::do_log(
                'notice',
                'Cannot keep a copy of incoming messages: no write access to %s',
                $main::options{'keepcopy'}
            );
            delete $main::options{'keepcopy'};
        }
    }

    ## Catch signals, in order to exit cleanly, whenever possible.
    $SIG{'TERM'} = 'sigterm';
    $SIG{'INT'}  = \&sigterm; # Interrupt from terminal.
    $SIG{'HUP'}  = 'sighup';
    $SIG{'PIPE'} = 'IGNORE';  ## Ignore SIGPIPE ; prevents sympa.pl from dying

    my $index_queuedigest = 0;    # verify the digest queue
    my $index_cleanqueue  = 0;
    my @qfile;

    my $spool = $Conf::Conf{'queue'};
# if daemon is dedicated to message or automatic lists creation, change the
# current spool
    if ($main::daemon_usage == Conf::DAEMON_MESSAGE) {
        $spool = $Conf::Conf{'queuedistribute'};
    } elsif ($main::daemon_usage == Conf::DAEMON_CREATION) {
        $spool = $Conf::Conf{'queueautomatic'};
    }

## This is the main loop : look for files in the directory, handles
## them, sleeps a while and continues the good job.
    while (!$signal) {
        $language->set_lang($default_lang);

        List::init_list_cache();
        # Process grouped notifications
        List::send_notify_to_listmaster(undef, undef, undef, 1);

        if (!opendir(DIR, $spool)) {
            die sprintf 'Can\'t open dir %s: %s', $spool, $!;
            ## No return.
        }
        @qfile = sort tools::by_date grep (!/^\./, readdir(DIR));
        closedir(DIR);

        unless ($main::daemon_usage == Conf::DAEMON_COMMAND) {
            # process digest only in distribution mode
            ## Scan queuedigest
            if ($index_queuedigest++ >= $digestsleep) {
                $index_queuedigest = 0;
                SendDigest();
            }
        }
        unless ($main::daemon_usage == Conf::DAEMON_MESSAGE) {
            # process expire and bads only in command mode

            ## Clean queue (bad)
            if ($index_cleanqueue++ >= 100) {
                $index_cleanqueue = 0;
                if (-e "$spool/bad") {
                    tools::CleanSpool("$spool/bad",
                        $Conf::Conf{'clean_delay_queue'});
                }
                tools::CleanSpool($Conf::Conf{'queuemod'},
                    $Conf::Conf{'clean_delay_queuemod'});
                if (-e $Conf::Conf{'queueoutgoing'} . '/bad') {
                    tools::CleanSpool(
                        $Conf::Conf{'queueoutgoing'} . '/bad',
                        $Conf::Conf{'clean_delay_queueoutgoing'}
                    );
                }
                if (-e $Conf::Conf{'queuebounce'} . '/bad') {
                    tools::CleanSpool(
                        $Conf::Conf{'queuebounce'} . '/bad',
                        $Conf::Conf{'clean_delay_queuebounce'}
                    );
                }
                tools::CleanSpool($Conf::Conf{'queueauth'},
                    $Conf::Conf{'clean_delay_queueauth'});
                tools::CleanSpool($Conf::Conf{'queuetopic'},
                    $Conf::Conf{'clean_delay_queuetopic'});
                tools::CleanSpool($Conf::Conf{'tmpdir'},
                    $Conf::Conf{'clean_delay_tmpdir'});
                tools::CleanSpool($Conf::Conf{'queuesubscribe'},
                    $Conf::Conf{'clean_delay_queuesubscribe'});
                tools::CleanSpool($Conf::Conf{'queueautomatic'},
                    $Conf::Conf{'clean_delay_queueautomatic'});
            }
        }

        ## Cleanup in-memory msgid table, only in a while
        if (time > $latest_msgid_table_cleanup +
            $Conf::Conf{'msgid_table_cleanup_frequency'}) {
            clean_msgid_table();
            $latest_msgid_table_cleanup = time;
        }

        my $filename;
        my $listname;
        my $robot;

        my $highest_priority = 'z';    ## lowest priority
        my $t_spool =
            $spool; ## in single mode we may have to supervise automatic spool

        ## Scans files in queue
        ## Search file with highest priority
        foreach my $t_filename (@qfile) {
            my $priority;
            my $type;
            my $list;
            my ($t_listname, $t_robot);

            ## test ever if it is an old bad file
            if ($t_filename =~ /^BAD\-/i) {
                if (tools::get_mtime("$t_spool/$t_filename") <
                    time -
                    Conf::get_robot_conf($robot, 'clean_delay_queue') * 86400)
                {
                    unlink("$t_spool/$t_filename");
                    Log::do_log('notice',
                        "Deleting bad message %s because too old",
                        $t_filename);
                }
                next;
            }

            ## z and Z are a null priority, so file stay in queue and are
            ## processed
            ## only if renamed by administrator
            next unless ($t_filename =~ /^(\S+)\.\d+\.\w+$/);

            ## Don't process temporary files created by queue (T.xxx)
            next if ($t_filename =~ /^T\./);

            ($t_listname, $t_robot) = split(/\@/, $1);

            $t_listname = lc($t_listname);
            if ($t_robot) {
                $t_robot = lc($t_robot);
            } else {
                $t_robot = lc(Conf::get_robot_conf($robot, 'host'));
            }

            my $list_check_regexp =
                Conf::get_robot_conf($robot, 'list_check_regexp');

            if ($t_listname =~ /^(\S+)-($list_check_regexp)$/) {
                ($t_listname, $type) = ($1, $2);
            }

            # (sa) le terme "(\@$Conf::Conf{'host'})?" est inutile
            #unless ($t_listname =~ /^(sympa|$Conf::Conf{'listmaster_email'}|$Conf::Conf{'email'})(\@$Conf::Conf{'host'})?$/i) {
            #    $list = List->new($t_listname);
            #}

            my $email = Conf::get_robot_conf($robot, 'email');

            if ($t_listname eq $Conf::Conf{'listmaster_email'}) {
                ## highest priority
                $priority = 0;
            } elsif ($type and $type eq 'request') {
                $priority = Conf::get_robot_conf($robot, 'request_priority');
            } elsif ($type and $type eq 'owner') {
                $priority = Conf::get_robot_conf($robot, 'owner_priority');
            } elsif (
                $t_listname =~ /^(sympa|$email)(\@$Conf::Conf{'host'})?$/i) {
                $priority = Conf::get_robot_conf($robot, 'sympa_priority');
            } else {
                my $list =
                    List->new($t_listname, $t_robot, {'just_try' => 1});
                if ($list) {
                    $priority = $list->{'admin'}{'priority'};
                } else {
                    $priority =
                        Conf::get_robot_conf($robot, 'default_list_priority');
                }
            }

            if (ord($priority) < ord($highest_priority)) {
                $highest_priority = $priority;
                $filename         = $t_filename;
            }
        }    ## END of spool lookup

        mail::reaper();

        unless ($filename) {
            sleep($Conf::Conf{'sleep'});
            next;
        }

        Log::do_log('debug', "Processing %s/%s with priority %s",
            $t_spool, $filename, $highest_priority);

        ## Set NLS default lang for current message
        $language->set_lang(Conf::get_robot_conf($robot, 'lang'),
            $default_lang);

        # Appel de la fonction de traitement des mails entrants
        my $status = DoFile("$t_spool/$filename");

        if (defined($status)) {
            Log::do_log('debug', "Finished %s", "$t_spool/$filename");

            if ($main::options{'keepcopy'}) {
                unless (
                    File::Copy::copy(
                        $t_spool . '/' . $filename,
                        $main::options{'keepcopy'} . '/' . $filename
                    )
                    ) {
                    Log::do_log(
                        'notice',
                        'Could not rename %s to %s: %s',
                        "$t_spool/$filename",
                        $main::options{'keepcopy'} . "/$filename",
                        $!
                    );
                }
            }
            unlink("$t_spool/$filename");
        } else {
            my $bad_dir = "$t_spool/bad";

            if (-d $bad_dir) {
                unless (rename("$t_spool/$filename", "$bad_dir/$filename")) {
                    die sprintf
                        'Unable to rename bad file %s to %s/%s: %s',
                        $filename, $bad_dir, $filename, $!;
                }
                Log::do_log('notice', "Moving bad file %s to bad/",
                    $filename);
            } else {
                Log::do_log('notice', 'Missing directory "%s"', $bad_dir);
                unless (
                    rename("$t_spool/$filename", "$t_spool/BAD-$filename")) {
                    die sprintf
                        'Unable to rename bad file %s to BAD-%s: %s',
                        $filename, $filename, $!;
                }
                Log::do_log('notice', "Renaming bad file %s to BAD-%s",
                    $filename, $filename);
            }
        }

    }    ## END of infinite loop

    # Purge grouped notifications
    List::send_notify_to_listmaster(undef, undef, undef, undef, 1);

## Dump of User files in DB
#List::dump();

## Disconnect from Database
    SDM::db_disconnect();

}    #end of block while ($signal ne 'term'){

Log::do_log('notice', 'Sympa exited normally due to signal');
my $file = 'sympa';
$file = 'sympa-distribute' if $main::daemon_usage == Conf::DAEMON_MESSAGE;
$file = 'sympa-creation'   if $main::daemon_usage == Conf::DAEMON_CREATION;
tools::remove_pid($file, $$);

exit(0);

############################################################
# sigterm
############################################################
#  When we catch signal, just changes the value of the $signal
#  loop variable.
#
# IN : -
#
# OUT : -
#
############################################################
sub sigterm {
    my ($sig) = @_;
    Log::do_log('notice', 'Signal %s received, still processing current task',
        $sig);
    $signal = 'term';
}

############################################################
# sighup
############################################################
#  When we catch SIGHUP, changes the value of the $signal
#  loop variable and puts the "-mail" logging option
#
# IN : -
#
# OUT : -
#
###########################################################
sub sighup {
    if ($mail::log_smtp) {
        Log::do_log('notice',
            'signal HUP received, switch of the "-mail" logging option and continue current task'
        );
        undef $mail::log_smtp;
    } else {
        Log::do_log('notice',
            'signal HUP received, switch on the "-mail" logging option and continue current task'
        );
        $mail::log_smtp = 1;
    }
    $signal = 'hup';
}

############################################################
#  DoFile
############################################################
#  Handles a file received and files in the queue directory.
#  This will read the file, separate the header and the body
#  of the message and call the adequate function wether we
#  have received a command or a message to be redistributed
#  to a list.
#
# IN : -$file (+): the file to handle
#
# OUT : $status
#     | undef
#
##############################################################
sub DoFile {
    my ($file) = @_;
    Log::do_log('debug', '(%s)', $file);

    my $status;

    my $message = Message->new({'file' => $file});

    unless (defined $message) {
        Log::do_log('err', 'Unable to create Message object %s', $file);
        Log::db_log(
            {
                #'robot'        => $robot,
                #'list'         => $listname,
                'action'       => 'DoFile',
                'parameters'   => "$file",
                'target_email' => "",
                'msg_id'       => '',
                'status'       => 'error',
                'error_type'   => 'unable_create_message',
                'user_email'   => '',
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    my $msg    = $message->{'msg'};
    my $hdr    = $msg->head;
    my $rcpt   = $message->{'rcpt'};
    my $from   = $hdr->get('From');
    my $msg_id = $hdr->get('Message-ID');

    Log::do_log('notice', 'Processing %s; sender: %s; message ID: %s',
        $file, $from, $msg_id);

    ## get listname & robot
    my ($listname, $robot) = split(/\@/, $rcpt);

    $robot    = lc($robot);
    $listname = lc($listname);
    $robot ||= $Conf::Conf{'host'};

    ## Ignoring messages with no sender
    my $sender = $message->{'sender'};
    unless ($message->{'md5_check'} or $sender) {
        Log::do_log('err', 'No From found in message, skipping');
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $listname,
                'action'       => 'DoFile',
                'parameters'   => "$file",
                'target_email' => "",
                'msg_id'       => $msg_id,
                'status'       => 'error',
                'error_type'   => 'no_sender',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    ## Unknown robot
    unless ($message->{'md5_check'} or Conf::valid_robot($robot)) {
        Log::do_log('err', 'Robot %s does not exist', $robot);
        report::reject_report_msg('user', 'list_unknown', $sender,
            {'listname' => $listname, 'message' => $message},
            '*', $message->{'msg'}->as_string, '');
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $listname,
                'action'       => 'DoFile',
                'parameters'   => "$file",
                'target_email' => "",
                'msg_id'       => $msg_id,
                'status'       => 'error',
                'error_type'   => 'unknown_robot',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    my $type;
    my $list_check_regexp = Conf::get_robot_conf($robot, 'list_check_regexp');
    if ($listname =~ /^(\S+)-($list_check_regexp)$/) {
        ($listname, $type) = ($1, $2);
    }

    if ($message->{'md5_check'}) {
        # message contain a valid checksum, it comes from wwsympa, so
        #  mail it without other proceding unless it is for a valid list
        unless (Conf::valid_robot($robot, {'just_try' => 1})) {
            # Enable SMTP logging if required.
            $mail::log_smtp = $main::options{'mail'}
                || tools::smart_eq($Conf::Conf{'log_smtp'}, 'on');
            # setting log_level using conf unless it is set by calling option
            Log::set_log_level(
                (defined $main::options{'log_level'})
                ? $main::options{'log_level'}
                : $Conf::Conf{'log_level'}
            );

            return DoSendMessage($message, '*');
        }
        unless (List->new($listname, $robot, {'just_try' => 1})) {
            # Enable SMTP logging if required.
            $mail::log_smtp = $main::options{'mail'}
                || tools::smart_eq(Conf::get_robot_conf($robot, 'log_smtp'),
                'on');
            # setting log_level using conf unless it is set by calling option
            Log::set_log_level(
                (defined $main::options{'log_level'})
                ? $main::options{'log_level'}
                : Conf::get_robot_conf($robot, 'log_level')
            );

            return DoSendMessage($message, $robot);
        }
    }

    # Enable SMTP logging if required.
    $mail::log_smtp = $main::options{'mail'}
        || Conf::get_robot_conf($robot, 'log_smtp');
    # setting log_level using conf unless it is set by calling option
    unless (defined $main::options{'log_level'}) {
        Log::set_log_level(Conf::get_robot_conf($robot, 'log_level'));
        Log::do_log('debug',
            'Setting log level with %s configuration (or sympa.conf): %d',
            $robot, Conf::get_robot_conf($robot, 'log_level'));
    }

    ## Strip of the initial X-Sympa-To and X-Sympa-Checksum internal headers
    $hdr->delete('X-Sympa-To');
    $hdr->delete('X-Sympa-Checksum');

    ## Initialize command report
    report::init_report_cmd();

    ## Maybe we are an automatic list
    #_amr ici on ne doit prendre que la premire ligne !
    my ($dyn_list_family, $dyn_just_created);
    # we care of fake headers. If we put it, it's the 1st one.
    if ($hdr->as_string() =~ /^X-Sympa-Family/mo) {
        $dyn_list_family = $hdr->get('X-Sympa-Family');
        chomp $dyn_list_family;
    }
    if ($main::daemon_usage == Conf::DAEMON_CREATION && !$dyn_list_family) {
        Log::do_log('err',
            'internal server error : automatic lists creation daemon should never proceed messages without X-Sympa-Family header'
        );
        report::global_report_cmd('intern',
            'Automatic lists creation daemon with message without header',
            {}, $sender, $robot, 1);
        return undef;
    }
    $hdr->delete('X-Sympa-Family');

    my $list_address;
    my $conf_email = Conf::get_robot_conf($robot, 'email');
    my $conf_host  = Conf::get_robot_conf($robot, 'host');

    my ($list, $host, $name);
    if ($listname =~
        /^(sympa|$Conf::Conf{'listmaster_email'}|$conf_email)(\@$conf_host)?$/i
        ) {
        $host         = $conf_host;
        $name         = $listname;
        $list_address = $name . '@' . $host;
    } else {
        $list = List->new($listname, $robot);
        unless (defined $list) {
            unless ($dyn_list_family) {
                Log::do_log('err', 'List %s does not exist', $listname);
                report::reject_report_msg(
                    'user',
                    'list_unknown',
                    $sender,
                    {'listname' => $listname, 'message' => $message},
                    $robot,
                    $message->{'msg'}->as_string,
                    ''
                );
                Log::db_log(
                    {   'robot'        => $robot,
                        'list'         => $listname,
                        'action'       => 'DoFile',
                        'parameters'   => "$file",
                        'target_email' => "",
                        'msg_id'       => $msg_id,
                        'status'       => 'error',
                        'error_type'   => 'unknown_list',
                        'user_email'   => $sender,
                        'client'       => $ip,
                        'daemon'       => $daemon_name
                    }
                );
                return undef;
            }

            ## Automatic creation of a mailing list, based on a family
            my $dyn_family;
            unless ($dyn_family = Family->new($dyn_list_family, $robot)) {
                Log::do_log('err',
                    "Failed to process $file : family $dyn_list_family does not exist, impossible to create the dynamic list."
                );
                List::send_notify_to_listmaster(
                    'automatic_list_creation_failed',
                    $robot,
                    {   'family' => $dyn_list_family,
                        'robot'  => $robot,
                        'msg_id' => $msg_id,
                    }
                );
                # FIXME: send DSN.
                report::reject_report_msg(
                    'user',
                    'list_unknown',
                    $sender,
                    {'listname' => $listname, 'message' => $message},
                    $robot,
                    $message->{'msg'}->as_string,
                    ''
                );
                return undef;
            }

            my $auth_level = 'smtp';
            $auth_level = 'dkim'  if $message->{'dkim_pass'};
            $auth_level = 'md5'   if $message->{'md5_check'};
            $auth_level = 'smime' if $message->{'smime_signed'};
            if ($list = $dyn_family->create_automatic_list(
                    (   'listname'   => $listname,
                        'auth_level' => $auth_level,
                        'sender'     => $sender,
                        'message'    => $message
                    )
                )
                ) {
                $dyn_just_created = 1;
            } else {
                Log::do_log('err',
                    'Unable to create list %s. Message %s ignored',
                    $listname, 'msg_id' => $hdr->get('Message-Id'));
                List::send_notify_to_listmaster(
                    'automatic_list_creation_failed',
                    $dyn_family->{'robot'},
                    {   'listname' => $listname,
                        'family'   => $dyn_list_family,
                        'robot'    => $robot,
                        'msg_id'   => $msg_id,
                    }
                );
                # FIXME: send DSN.
                report::reject_report_msg(
                    'user',
                    'dyn_cant_create',
                    $sender,
                    {'listname' => $listname, 'message' => $message},
                    $robot,
                    $message->{'msg_as_string'},
                    ''
                );
                Log::db_log(
                    {   'robot'      => $dyn_family->{'robot'},
                        'list'       => $listname,
                        'action'     => 'DoFile',
                        'parameters' => $hdr->get('Message-Id')
                            . ",$dyn_family->{'robot'}",
                        'target_email' => '',
                        'msg_id'       => $hdr->get('Message-Id'),
                        'status'       => 'error',
                        'error_type'   => 'internal',
                        'user_email'   => $sender,
                        'client'       => $ip,
                        'daemon'       => $daemon_name
                    }
                );
                return undef;
            }
        }
        $host         = $list->{'admin'}{'host'};
        $name         = $list->{'name'};
        $list_address = $list->get_list_address();
    }
    ## Loop prevention
    if (tools::smart_eq(
            $list->{'admin'}{'reject_mail_from_automates_feature'}, 'on'
        )
        ) {
        my $conf_loop_prevention_regex;
        $conf_loop_prevention_regex =
            $list->{'admin'}{'loop_prevention_regex'};
        $conf_loop_prevention_regex ||=
            Conf::get_robot_conf($robot, 'loop_prevention_regex');
        if ($sender =~ /^($conf_loop_prevention_regex)(\@|$)/mio) {
            Log::do_log(
                'err',
                'Ignoring message which would cause a loop, sent by %s; matches loop_prevention_regex',
                $sender
            );
            return undef;
        }

        ## Ignore messages that would cause a loop
        ## Content-Identifier: Auto-replied is generated by some non standard
        ## X400 mailer
        if (   grep {/Auto-replied/i} $hdr->get('Content-Identifier')
            or grep {/Auto Reply to/i} $hdr->get('X400-Content-Identifier')
            or grep { !/^no$/i } $hdr->get('Auto-Submitted')) {
            Log::do_log('err',
                "Ignoring message which would cause a loop; message appears to be an auto-reply"
            );
            return undef;
        }
    }

    ## Q- and B-decode subject
    my $subject_field = $message->{'decoded_subject'};

    ## Loop prevention
    my $loop;
    foreach $loop ($hdr->get('X-Loop')) {
        chomp $loop;
        Log::do_log('debug2', 'X-Loop: %s', $loop);
        #foreach my $l (split(/[\s,]+/, lc($loop))) {
        if ($loop eq lc($list_address)) {
            Log::do_log('err',
                'Ignoring message which would cause a loop (X-Loop: %s)',
                $loop);
            return undef;
        }
        #}
    }

    ## S/MIME or DKIM signed messages
    if ($message->{'smime_signed'}) {
        $is_signed = {
            # subject semantic is relater to X509 (subject is the private key
            # owner, not the message Subject header !)
            'subject' => $message->{'smime_subject'},
            'body'    => 'smime'
        };
    } else {
        undef $is_signed;
    }

    #  anti-virus
    my $rc = tools::virus_infected($message->{'msg'}, $message->{'filename'});
    if ($rc) {
        if (Conf::get_robot_conf($robot, 'antivirus_notify') eq 'sender') {
            unless (
                List::send_global_file(
                    'your_infected_msg',
                    $sender, $robot,
                    {   'virus_name' => $rc,
                        'recipient'  => $list_address,
                        'lang'       => Conf::get_robot_conf($robot, 'lang'),
                        'auto_submitted' => 'auto-replied'
                    }
                )
                ) {
                Log::do_log('notice',
                    'Unable to send template "your infected_msg" to %s',
                    $sender);
            }
        }
        Log::do_log('notice',
            "Message for %s from %s ignored, virus %s found",
            $list_address, $sender, $rc);
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $listname,
                'action'       => 'DoFile',
                'parameters'   => "$file",
                'target_email' => "",
                'msg_id'       => $msg_id,
                'status'       => 'error',
                'error_type'   => 'virus',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;

    } elsif (!defined($rc)) {
        List::send_notify_to_listmaster('antivirus_failed', $robot,
            ["Could not scan $file; The message has been saved as BAD."]);

        return undef;
    }

    if ($main::daemon_usage == Conf::DAEMON_MESSAGE) {
        if (   ($rcpt =~ /^$Conf::Conf{'listmaster_email'}(\@(\S+))?$/)
            || ($rcpt =~ /^(sympa|$conf_email)(\@\S+)?$/i)
            || ($type =~ /^(subscribe|unsubscribe)$/o)
            || ($type =~ /^(request|owner|editor)$/o)) {
            Log::do_log('err',
                'internal serveur error : distribution daemon should never proceed with command'
            );
            report::global_report_cmd('intern',
                'Distribution daemon proceed with command',
                {}, $sender, $robot, 1);
            Log::db_log(
                {   'robot'        => $robot,
                    'list'         => $listname,
                    'action'       => 'DoFile',
                    'parameters'   => "$file",
                    'target_email' => "",
                    'msg_id'       => $msg_id,
                    'status'       => 'error',
                    'error_type'   => 'internal',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }
    }

    if ($main::daemon_usage == Conf::DAEMON_CREATION
        || (($Conf::Conf{'automatic_list_feature'} eq 'on')
            && $main::daemon_usage == Conf::DAEMON_ALL)
        ) {
        if ($dyn_list_family && $dyn_just_created) {
            unless (defined $list->sync_include()) {
                Log::do_log(
                    'err',
                    'Failed to synchronize list members of dynamic list %s from %s family',
                    $listname,
                    $dyn_list_family
                );
                report::reject_report_msg(
                    'user',
                    'dyn_cant_create',
                    $sender,
                    {'listname' => $listname, 'message' => $message},
                    $robot,
                    $message->{'msg'}->as_string,
                    ''
                );
                Log::db_log(
                    {   'robot'        => $robot,
                        'list'         => $listname,
                        'action'       => 'DoFile',
                        'parameters'   => "$file",
                        'target_email' => "",
                        'msg_id'       => $msg_id,
                        'status'       => 'error',
                        'error_type'   => 'dyn_cant_sync',
                        'user_email'   => $sender,
                        'client'       => $ip,
                        'daemon'       => $daemon_name
                    }
                );
                # purge the unwanted empty automatic list
                if ($Conf::Conf{'automatic_list_removal'} =~ /if_empty/i) {
                    $list->close_list();
                    # verifier pour tt ce bloc si supprime bien tout
                    $list->purge();
                    # but what about list_of_lists ?
                    if (exists $List::list_of_lists{$list->{'domain'}}
                        {$list->{'name'}}) {    # test  virer si ok
                        delete $List::list_of_lists{$list->{'domain'}}
                            {$list->{'name'}};
                        Log::do_log(
                            'err',
                            'La liste a t trouve dans la list_of_lists',
                            $listname,
                            $dyn_list_family
                        );
                    }
                }
                return undef;
            }
            unless ($list->get_total() > 0) {
                Log::do_log('err',
                    'Dynamic list %s from %s family has ZERO subscribers',
                    $listname, $dyn_list_family);
                report::reject_report_msg(
                    'user',
                    'list_unknown',
                    $sender,
                    {   'listname' => $listname,
                        'list'     => {'name' => $listname, 'host' => $robot},
                        'message'  => $message
                    },
                    $robot,
                    $message->{'msg'}->as_string,
                    ''
                );
                Log::db_log(
                    {   'robot'        => $robot,
                        'list'         => $listname,
                        'action'       => 'DoFile',
                        'parameters'   => "$file",
                        'target_email' => "",
                        'msg_id'       => $msg_id,
                        'status'       => 'error',
                        'error_type'   => 'list_unknown',
                        'user_email'   => $sender,
                        'client'       => $ip,
                        'daemon'       => $daemon_name
                    }
                );
                # purge the unwanted empty automatic list
                if ($Conf::Conf{'automatic_list_removal'} =~ /if_empty/i) {
                    $list->close_list();
                    # verifier pour tt ce bloc si supprime bien tout
                    $list->purge();
                    # but what about list_of_lists ?
                    if (exists $List::list_of_lists{$list->{'domain'}}
                        {$list->{'name'}}) {    # test  virer si ok
                        delete $List::list_of_lists{$list->{'domain'}}
                            {$list->{'name'}};
                        Log::do_log(
                            'err',
                            'La liste a t trouve dans la list_of_lists',
                            $listname,
                            $dyn_list_family
                        );
                    }
                }
                return undef;
            }
            Log::do_log('info',
                'Successfully create list %s with %s subscribers',
                $listname, $list->get_total());
        }
    }

    if ($main::daemon_usage == Conf::DAEMON_CREATION) {
        # do not process messages in list creation only mode, move them to
        # main spool
        unless (
            $list->move_message($message->{'filename'}, $Conf::Conf{'queue'}))
        {
            Log::do_log(
                'err',
                'Unable to move in spool for processing message to list %s (daemon_usage = creation)',
                $listname
            );
            report::reject_report_msg('intern', '', $sender,
                {'msg_id' => $msg_id, 'message' => $message},
                $robot, $message->{'msg_as_string'}, $list);
            return undef;
        }
        Log::do_log(
            'info',
            ($dyn_just_created ? 'After automatic list creation, ' : '')
                . 'Message for %s from %s moved in spool %s for processing message-id=%s',
            $listname,
            $sender,
            $Conf::Conf{'queue'},
            $msg_id
        );
        $status = 1;

    } elsif ($rcpt =~ /^listmaster(\@(\S+))?$/) {
        $status = DoForward('sympa', 'listmaster', $robot, $message);

        ## Mail addressed to the robot and mail
        ## to <list>-subscribe or <list>-unsubscribe are commands
    } elsif (($rcpt =~ /^(sympa|$conf_email)(\@\S+)?$/i)
        or ($type and $type =~ /^(subscribe|unsubscribe)$/o)) {
        $status = DoCommand($rcpt, $robot, $message);

        ## forward mails to <list>-request <list>-owner etc
    } elsif ($type and $type =~ /^(request|owner|editor)$/o) {
        ## Simulate Smartlist behaviour with command in subject
        if (($type eq 'request')
            and (
                tools::smart_eq(
                    $subject_field,
                    qr/^\s*(subscribe|unsubscribe)(\s*$listname)?\s*$/i
                )
            )
            ) {
            my $command = $1;

            $status = DoCommand("$listname-$command", $robot, $message);
        } else {
            $status = DoForward($listname, $type, $robot, $message);
        }
    } else {
        $status = DoMessage($rcpt, $message, $robot);
    }

    ## Mail back the result.
    if (report::is_there_any_report_cmd()) {

        ## Loop prevention

        ## Count reports sent to $sender
        $loop_info{$sender}{'count'}++;

        ## Sampling delay
        if ((time - ($loop_info{$sender}{'date_init'} || 0)) <
            $Conf::Conf{'loop_command_sampling_delay'}) {

            ## Notify listmaster of first rejection
            if ($loop_info{$sender}{'count'} ==
                $Conf::Conf{'loop_command_max'}) {
                ## Notify listmaster
                List::send_notify_to_listmaster(
                    'loop_command',
                    Conf::get_robot_conf($robot, 'domain'),
                    {'msg' => $file}
                );
            }

            ## Too many reports sent => message skipped !!
            if ($loop_info{$sender}{'count'} >=
                $Conf::Conf{'loop_command_max'}) {
                Log::do_log(
                    'err',
                    'Ignoring message which would cause a loop, %d messages sent to %s; loop_command_max exceeded',
                    $loop_info{$sender}{'count'},
                    $sender
                );

                return undef;
            }
        } else {
            ## Sampling delay is over, reinit
            $loop_info{$sender}{'date_init'} = time;

            ## We apply Decrease factor if a loop occurred
            $loop_info{$sender}{'count'} *=
                $Conf::Conf{'loop_command_decrease_factor'};
        }

        ## Send the reply message
        report::send_report_cmd($sender, $robot);
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $listname,
                'action'       => 'DoFile',
                'parameters'   => "$file",
                'target_email' => "",
                'msg_id'       => $msg_id,
                'status'       => 'success',
                'error_type'   => '',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );

    }

    return $status;
}

############################################################
#  DoSendMessage
############################################################
#  Send a message pushed in spool by another process.
#
# IN : -$msg (+): ref(MIME::Entity)
#      -$robot (+) :robot
#
# OUT : 1
#     | undef
#
##############################################################
sub DoSendMessage {
    my $message = shift;
    my $robot   = shift;
    Log::do_log('debug', '');

    my $hdr = $message->{'msg'}->head;

    my $chksum = $hdr->get('X-Sympa-Checksum');
    my $rcpt   = $hdr->get('X-Sympa-To');
    my $from   = $hdr->get('X-Sympa-From');
    chomp $rcpt;
    chomp $chksum;
    chomp $from;

    Log::do_log('info', "Processing web message for %s", $rcpt);

    my $string = $message->{'msg'}->as_string;
    my $msg_id = $hdr->get('Message-ID');
    my $sender = $hdr->get('From');

    $hdr->delete('X-Sympa-Checksum');
    $hdr->delete('X-Sympa-To');
    $hdr->delete('X-Sympa-From');

    ## Multiple recepients
    my @rcpts = split /,/, $rcpt;

    unless (mail::mail_forward($message, $from, \@rcpts, $robot)) {
        Log::do_log('err', 'Impossible to forward mail from %s', $from);
        report::reject_report_msg(
            'intern',
            'Impossible to forward a message pushed in spool by another process than sympa.pl.',
            $sender,
            {'msg_id' => $msg_id, 'message' => $message->{'msg'}},
            $robot,
            $string,
            ''
        );
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $rcpt,
                'action'       => 'sendMessage',
                'parameters'   => "$msg_id,$rcpt",
                'target_email' => '',
                'msg_id'       => $msg_id,
                'status'       => 'error',
                'error_type'   => 'internal',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    Log::do_log('info', "Message for %s sent", $rcpt);
    Log::db_log(
        {   'robot'        => $robot,
            'list'         => $rcpt,
            'action'       => 'sendMessage',
            'parameters'   => "$msg_id,$rcpt",
            'target_email' => '',
            'msg_id'       => $msg_id,
            'status'       => 'succes',
            'error_type'   => '',
            'user_email'   => $sender,
            'client'       => $ip,
            'daemon'       => $daemon_name
        }
    );

    return 1;
}

############################################################
#  DoForward
############################################################
#  Handles a message sent to [list]-editor : the list editor,
#  [list]-request : the list owner or the listmaster.
#  Message is forwarded according to $function
#
# IN : -$name : list name (+) if ($function <> 'listmaster')
#      -$function (+): 'listmaster'|'request'|'editor'
#      -$robot (+): robot
#      -$msg (+): ref(message object).
#
# OUT : 1
#     | undef
#
############################################################
sub DoForward {
    my ($name, $function, $robot, $message) = @_;
    Log::do_log('debug', '(%s, %s)', $name, $function);

    my $msg        = $message->{'msg'};
    my $hdr        = $msg->head;
    my $messageid  = $hdr->get('Message-Id');
    my $msg_string = $msg->as_string;
    my $sender     = $hdr->get('From');
    chomp $sender;

    if ($message->{'spam_status'} eq 'spam') {
        Log::do_log(
            'notice',
            'Message for %s-%s ignored, because tagued as spam (message ID: %s)',
            $name,
            $function,
            $messageid
        );
        return undef;
    }

    ##  Search for the list
    my ($list, $admin, $host, $recepient, $priority);

    if ($function eq 'listmaster') {
        $recepient = $Conf::Conf{'listmaster_email'};
        $host      = Conf::get_robot_conf($robot, 'host');
        $priority  = 0;
    } else {
        unless ($list = List->new($name, $robot)) {
            Log::do_log(
                'notice',
                'Message for %s-%s ignored, unknown list %s (message ID: %s)',
                $name,
                $function,
                $name,
                $messageid
            );
            my $sympa_email = Conf::get_robot_conf($robot, 'sympa');
            unless (
                List::send_global_file(
                    'list_unknown',
                    $sender, $robot,
                    {   'list' => $name,
                        'date' => POSIX::strftime(
                            "%d %b %Y  %H:%M",
                            localtime(time)
                        ),
                        'boundary'       => $sympa_email . time,
                        'header'         => $hdr->as_string(),
                        'auto_submitted' => 'auto-replied'
                    }
                )
                ) {
                Log::do_log('notice',
                    'Unable to send template "list_unknown" to %s', $sender);
            }
            return undef;
        }

        $admin     = $list->{'admin'};
        $host      = $admin->{'host'};
        $recepient = "$name-$function";
        $priority  = $admin->{'priority'};
    }

    my @rcpt;

    Log::do_log('info',
        'Processing message for %s with priority %s, (message ID:%s)',
        $recepient, $priority, $messageid);

    $hdr->add('X-Loop', "$name-$function\@$host");
    $hdr->delete('X-Sympa-To');
    $hdr->delete('X-Sympa-Family');

    if ($function eq "listmaster") {
        my $listmasters = Conf::get_robot_conf($robot, 'listmasters');
        @rcpt = @{$listmasters};
        Log::do_log('notice', 'Warning: No listmaster defined in sympa.conf')
            unless (@rcpt);

    } elsif ($function eq "request") {
        @rcpt = $list->get_owners_email();

        Log::do_log(
            'notice',
            'Warning: No owner defined or all of them use nomail option in list %s',
            $name
        ) unless (@rcpt);

    } elsif ($function eq "editor") {
        @rcpt = $list->get_editors_email();

        Log::do_log(
            'notice',
            'Warning: No owner and editor defined or all of them use nomail option in list %s',
            $name
        ) unless (@rcpt);
    }

    ## Did we find a recipient?
    if ($#rcpt < 0) {
        if ($function ne "listmaster") {
            Log::do_log(
                'err',
                'No recipient available for %s-%s in list %s. Trying to proceed ignoring nomail option (message ID %s)',
                $name,
                $function,
                $name,
                $messageid
            );

            if ($function eq "request") {
                @rcpt = $list->get_owners_email({'ignore_nomail', 1});

                Log::do_log('notice',
                    'Warning: No owner defined at all in list %s', $name)
                    unless (@rcpt);

            } elsif ($function eq "editor") {
                @rcpt = $list->get_editors_email({'ignore_nomail', 1});

                Log::do_log(
                    'notice',
                    'Warning: No owner and editor defined at all in list %s',
                    $name
                ) unless (@rcpt);
            }
        }
        ## Could we find a recipient by ignoring the "nomail" option?
        if ($#rcpt >= 0) {
            Log::do_log(
                'notice',
                'All the intended recipients of message %s in list %s have set the "nomail" option. Ignoring it and sending it to all of them',
                $messageid,
                $name
            );
        } else {
            Log::do_log('err',
                'Message for %s-%s ignored, %s undefined in list %s',
                $name, $function, $function, $name);
            my $string =
                sprintf
                'Impossible to forward a message to %s-%s : undefined in this list',
                $name, $function;
            report::reject_report_msg(
                'intern', $string, $sender,
                {   'msg_id'   => $messageid,
                    'entry'    => 'forward',
                    'function' => $function,
                    'message'  => $msg
                },
                $robot,
                $msg_string,
                $list
            );
            Log::db_log(
                {   'robot'        => $robot,
                    'list'         => $list->{'name'},
                    'action'       => 'DoForward',
                    'parameters'   => "$name,$function",
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'internal',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }
    }

    # my $msg_copy = $msg->dup;
    $message->{'msg'} = $msg;
    unless (
        mail::mail_forward(
            $message, Conf::get_robot_conf($robot, 'request'),
            \@rcpt,   $robot
        )
        ) {
        Log::do_log('err', 'Impossible to forward mail for %s-%s',
            $name, $function);
        my $string = sprintf 'Impossible to forward a message for %s-%s',
            $name, $function;
        report::reject_report_msg(
            'intern', $string, $sender,
            {   'msg_id'   => $messageid,
                'entry'    => 'forward',
                'function' => $function,
                'message'  => $msg
            },
            $robot,
            $msg_string,
            $list
        );
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $list->{'name'},
                'action'       => 'DoForward',
                'parameters'   => "$name,$function",
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'internal',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }
    Log::db_log(
        {   'robot'        => $robot,
            'list'         => $list->{'name'},
            'action'       => 'DoForward',
            'parameters'   => "$name,$function",
            'target_email' => '',
            'msg_id'       => $messageid,
            'status'       => 'success',
            'error_type'   => '',
            'user_email'   => $sender,
            'client'       => $ip,
            'daemon'       => $daemon_name
        }
    );

    return 1;
}

####################################################
#  DoMessage
####################################################
#  Handles a message sent to a list. (Those that can
#  make loop and those containing a command are
#  rejected)
#
# IN : -$which (+): 'listname@hostname' - concerned list
#      -$message (+): ref(Message) - sent message
#      -$robot (+): robot
#
# OUT : 1 if ok (in order to remove the file from the queue)
#     | undef
#
####################################################
sub DoMessage {
    my ($which, $message, $robot) = @_;
    Log::do_log(
        'debug',            '(%s, %s, %s, msg from %s, %s, %s)',
        $which,             $message->{'msg'},
        $robot,             $message->{'sender'},
        $message->{'size'}, $message->{'smime_crypted'}
    );

    ## List and host.
    my ($listname, $host) = split(/[@\s]+/, $which);

    my $hdr = $message->{'msg'}->head;

    my $messageid  = $hdr->get('Message-Id');
    my $msg        = $message->{'msg'};
    my $msg_string = $msg->as_string;

    my $sender = $message->{'sender'};

    ## Search for the list
    my $list = List->new($listname, $robot);

    ## List unknown
    unless ($list) {
        Log::do_log('notice', 'Unknown list %s', $listname);
        my $sympa_email = Conf::get_robot_conf($robot, 'sympa');

        unless (
            List::send_global_file(
                'list_unknown',
                $sender, $robot,
                {   'list' => $which,
                    'date' =>
                        POSIX::strftime("%d %b %Y  %H:%M", localtime(time)),
                    'boundary'       => $sympa_email . time,
                    'header'         => $hdr->as_string(),
                    'auto_submitted' => 'auto-replied'
                }
            )
            ) {
            Log::do_log('notice',
                'Unable to send template "list_unknown" to %s', $sender);
        }
        return undef;
    }

    ($listname, $host) = ($list->{'name'}, $list->{'admin'}{'host'});

    my $start_time = time;

    $language->set_lang(
        $list->{'admin'}{'lang'},
        Conf::get_robot_conf($robot, 'lang'),
        $Conf::Conf{'lang'}, 'en'
    );

    ## Now check if the sender is an authorized address.

    Log::do_log('info', "Processing message for %s with priority %s, %s",
        $listname, $list->{'admin'}{'priority'}, $messageid);

    #FIXME: Might reject message when no message ID found.
    if ($messageid and $msgid_table{$list->get_list_id()}{$messageid}) {
        Log::do_log('err',
            'Found known Message-ID, ignoring message which would cause a loop'
        );
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $list->{'name'},
                'action'       => 'DoMessage',
                'parameters'   => "$which,$messageid,$robot",
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'known_message',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    # Reject messages with commands
    if ($Conf::Conf{'misaddressed_commands'} =~ /reject/i) {
        ## Check the message for commands and catch them.
        if (tools::checkcommand($message->{'msg'}, $sender, $robot)) {
            Log::do_log('err',
                'sympa::DoMessage(): Found command in message, ignoring message'
            );
            report::reject_report_msg('user', 'routing_error', $sender,
                {'message' => $message},
                $robot, $msg_string, $list);
            Log::db_log(
                {   'robot'        => $robot,
                    'list'         => $list->{'name'},
                    'action'       => 'DoMessage',
                    'parameters'   => "$which,$messageid,$robot",
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'routing_error',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }
    }

    my $admin = $list->{'admin'};
    unless ($admin) {
        Log::do_log('err', 'List config is undefined');
        report::reject_report_msg('intern', '', $sender,
            {'message' => $message},
            $robot, $msg_string, $list);
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $list->{'name'},
                'action'       => 'DoMessage',
                'parameters'   => "$which,$messageid,$robot",
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'internal',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    my $customheader = $admin->{'custom_header'};

    ## Check if the message is too large
    # my $max_size = $list->get_max_size() ||  Conf::get_robot_conf($robot,'max_size');
    my $max_size = $list->get_max_size();

    if ($max_size && $message->{'size'} > $max_size) {
        Log::do_log('info',
            'Message for %s from %s rejected because too large (%d > %d)',
            $listname, $sender, $message->{'size'}, $max_size);
        report::reject_report_msg(
            'user',
            'message_too_large',
            $sender,
            {   'msg_size' => int($message->{'size'} / 1024),
                'max_size' => int($max_size / 1024)
            },
            $robot, '', $list
        );
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $list->{'name'},
                'action'       => 'DoMessage',
                'parameters'   => "$which,$messageid,$robot",
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'message_too_large',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    my $rc;

    my $context = {
        'sender'  => $sender,
        'message' => $message
    };

    ## list msg topic
    if ($list->is_there_msg_topic()) {

        my $info_msg_topic = $list->load_msg_topic_file($messageid, $robot);

        # is msg already tagged ?
        if (ref($info_msg_topic) eq "HASH") {
            if ($info_msg_topic->{'method'} eq "sender") {
                $context->{'topic_sender'} = $info_msg_topic->{'topic'};

            } elsif ($info_msg_topic->{'method'} eq "editor") {
                $context->{'topic_editor'} = $info_msg_topic->{'topic'};

            } elsif ($info_msg_topic->{'method'} eq "auto") {
                $context->{'topic_auto'} = $info_msg_topic->{'topic'};
            }

            # not already tagged
        } else {
            $context->{'topic_auto'} = $list->automatic_tag($message);
        }

        $context->{'topic'} =
               $context->{'topic_auto'}
            || $context->{'topic_sender'}
            || $context->{'topic_editor'};
        $context->{'topic_needed'} =
            (!$context->{'topic'} && $list->is_msg_topic_tagging_required());
    }

    ## Call scenarii : auth_method MD5 do not have any sense in send
    ## scenarii because auth is perfom by distribute or reject command.

    my $action;
    my $result;

    # the order of the following 3 lines is important ! SMIME > DKIM > SMTP
    my $auth_method = 'smtp';
    $auth_method = 'dkim'  if ($message->{'dkim_pass'});
    $auth_method = 'md5'   if ($message->{'md5_check'});
    $auth_method = 'smime' if ($is_signed->{'body'});

    $result = $list->check_list_authz('send', $auth_method, $context);
    $action = $result->{'action'} if (ref($result) eq 'HASH');

    unless (defined $action) {
        Log::do_log(
            'err',
            'Message (%s) ignored because unable to evaluate scenario "send" for list %s',
            $messageid,
            $listname
        );
        report::reject_report_msg(
            'intern',
            'Message ignored because scenario "send" cannot be evaluated',
            $sender,
            {'msg_id' => $messageid, 'message' => $message},
            $robot,
            $msg_string,
            $list
        );
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $list->{'name'},
                'action'       => 'DoMessage',
                'parameters'   => "$which,$messageid,$robot",
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'internal',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    ## message topic context
    if (($action =~ /^do_it/) && ($context->{'topic_needed'})) {
        $action = 'editorkey'
            if (
            $list->{'admin'}{'msg_topic_tagging'} eq 'required_moderator');
        $action = 'request_auth'
            if ($list->{'admin'}{'msg_topic_tagging'} eq 'required_sender');
    }

    if (   ($action =~ /^do_it/)
        || ($main::daemon_usage == Conf::DAEMON_MESSAGE)) {

        if (   ($main::daemon_usage == Conf::DAEMON_MESSAGE)
            || ($main::daemon_usage == Conf::DAEMON_ALL)) {

            my $apply_dkim_signature = 'off';
            $apply_dkim_signature = 'on'
                if tools::is_in_array(
                $list->{'admin'}{'dkim_signature_apply_on'}, 'any');
            $apply_dkim_signature = 'on'
                if (
                tools::is_in_array(
                    $list->{'admin'}{'dkim_signature_apply_on'},
                    'smime_authenticated_messages')
                && ($is_signed->{'body'})
                );
            $apply_dkim_signature = 'on'
                if tools::is_in_array(
                $list->{'admin'}{'dkim_signature_apply_on'},
                'dkim_authenticated_messages')
                and $message->{'dkim_pass'};

            my $numsmtp;
            #XXX eval {
            $numsmtp = $list->distribute_msg(
                'message'              => $message,
                'apply_dkim_signature' => $apply_dkim_signature
            );
            #XXX };
            ## Keep track of known message IDs...if any
            $msgid_table{$list->get_list_id()}{$messageid} = time
                if $messageid;

            unless (defined($numsmtp)) {
                Log::do_log('err', 'Unable to send message to list %s',
                    $listname);
                report::reject_report_msg('intern', '', $sender,
                    {'msg_id' => $messageid, 'message' => $message},
                    $robot, $msg_string, $list);
                Log::db_log(
                    {   'robot'        => $robot,
                        'list'         => $list->{'name'},
                        'action'       => 'DoMessage',
                        'parameters'   => "$which,$messageid,$robot",
                        'target_email' => '',
                        'msg_id'       => $messageid,
                        'status'       => 'error',
                        'error_type'   => 'internal',
                        'user_email'   => $sender,
                        'client'       => $ip,
                        'daemon'       => $daemon_name
                    }
                );
                return undef;
            }
            Log::do_log(
                'info',
                'Message for %s from %s accepted (%d seconds, %d sessions, %d subscribers), message ID=%s, size=%d',
                $listname,
                $sender,
                time - $start_time,
                $numsmtp,
                $list->get_total(),
                $messageid,
                $message->{'size'}
            );

            return 1;

        } else {
            # this message is to be distributed but this daemon is dedicated
            # to commands or list creation -> move it to distribution spool
            unless (
                $list->move_message(
                    $message->{'filename'},
                    $Conf::Conf{'queuedistribute'}
                )
                ) {
                Log::do_log(
                    'err',
                    'Unable to move in spool for distribution message to list %s (daemon_usage = command)',
                    $listname
                );
                report::reject_report_msg('intern', '', $sender,
                    {'msg_id' => $messageid, 'message' => $message},
                    $robot, $msg_string, $list);
                Log::db_log(
                    {   'robot'        => $robot,
                        'list'         => $list->{'name'},
                        'action'       => 'DoMessage',
                        'parameters'   => "$which,$messageid,$robot",
                        'target_email' => '',
                        'msg_id'       => $messageid,
                        'status'       => 'error',
                        'error_type'   => 'internal',
                        'user_email'   => $sender,
                        'client'       => $ip,
                        'daemon'       => $daemon_name
                    }
                );
                return undef;
            }
            Log::do_log(
                'info',
                'Message for %s from %s moved in spool %s for distribution message ID=%s',
                $listname,
                $sender,
                $Conf::Conf{'queuedistribute'},
                $messageid
            );
            Log::db_log(
                {   'robot'        => $robot,
                    'list'         => $list->{'name'},
                    'action'       => 'DoMessage',
                    'parameters'   => "$which,$messageid,$robot",
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'success',
                    'error_type'   => 'moved_in_spool',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return 1;
        }

    } elsif ($action =~ /^request_auth/) {
        my $key = $list->send_auth($message);

        unless (defined $key) {
            Log::do_log(
                'err',
                'Calling to send_auth function failed for user %s in list %s',
                $sender,
                $list->{'name'}
            );
            report::reject_report_msg(
                'intern', 'The request authentication sending failed',
                $sender, {'msg_id' => $messageid, 'message' => $message},
                $robot, $msg_string,
                $list
            );
            Log::db_log(
                {   'robot'        => $robot,
                    'list'         => $list->{'name'},
                    'action'       => 'DoMessage',
                    'parameters'   => "$which,$messageid,$robot",
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'internal',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }
        Log::do_log('notice',
            'Message for %s from %s kept for authentication with key %s',
            $listname, $sender, $key);
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $list->{'name'},
                'action'       => 'DoMessage',
                'parameters'   => "$which,$messageid,$robot",
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'success',
                'error_type'   => 'kept_for_auth',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return 1;
    } elsif ($action =~ /^editorkey(\s?,\s?(quiet))?/) {
        my $quiet = $2;
        my $key = $list->send_to_editor('md5', $message);

        unless (defined $key) {
            Log::do_log(
                'err',
                'Calling to send_to_editor() function failed for user %s in list %s',
                $sender,
                $list->{'name'}
            );
            report::reject_report_msg(
                'intern',
                'The request moderation sending to moderator failed.',
                $sender,
                {'msg_id' => $messageid, 'message' => $message},
                $robot,
                $msg_string,
                $list
            );
            Log::db_log(
                {   'robot'        => $robot,
                    'list'         => $list->{'name'},
                    'action'       => 'DoMessage',
                    'parameters'   => "$which,$messageid,$robot",
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'internal',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }

        Log::do_log('info', 'Key %s for list %s from %s sent to editors, %s',
            $key, $listname, $sender, $message->{'filename'});

        # do not report to the sender if the message was tagged as a spam
        unless ($quiet or $message->{'spam_status'} eq 'spam') {
            unless (
                report::notice_report_msg(
                    'moderating_message', $sender,
                    {'message' => $message}, $robot,
                    $list
                )
                ) {
                Log::do_log('notice',
                    "sympa::DoMessage(): Unable to send template 'message_report', entry 'moderating_message' to $sender"
                );
            }
        }
        return 1;
    } elsif ($action =~ /^editor(\s?,\s?(quiet))?/) {
        my $quiet = $2;
        my $key = $list->send_to_editor('smtp', $message);

        unless (defined $key) {
            Log::do_log(
                'err',
                'Calling to send_to_editor() function failed for user %s in list %s',
                $sender,
                $list->{'name'}
            );
            report::reject_report_msg(
                'intern',
                'The request moderation sending to moderator failed.',
                $sender,
                {'msg_id' => $messageid, 'message' => $message},
                $robot,
                $msg_string,
                $list
            );
            Log::db_log(
                {   'robot'        => $robot,
                    'list'         => $list->{'name'},
                    'action'       => 'DoMessage',
                    'parameters'   => "$which,$messageid,$robot",
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'internal',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }

        Log::do_log('info', 'Message for %s from %s sent to editors',
            $listname, $sender);

        # do not report to the sender if the message was tagged as a spam
        unless ($quiet or $message->{'spam_status'} eq 'spam') {
            unless (
                report::notice_report_msg(
                    'moderating_message', $sender,
                    {'message' => $message}, $robot,
                    $list
                )
                ) {
                Log::do_log('notice',
                    "sympa::DoMessage(): Unable to send template 'message_report', type 'success', entry 'moderating_message' to $sender"
                );
            }
        }
        return 1;
    } elsif ($action =~ /^reject(,(quiet))?/) {
        my $quiet = $2;

        Log::do_log(
            'notice',
            'Message for %s from %s rejected(%s) because sender not allowed',
            $listname,
            $sender,
            $result->{'tt2'}
        );

        # do not report to the sender if the message was tagued as a spam
        unless ($quiet or $message->{'spam_status'} eq 'spam') {
            if (defined $result->{'tt2'}) {
                unless (
                    $list->send_file(
                        $result->{'tt2'}, $sender, $robot,
                        {'auto_submitted' => 'auto-replied'}
                    )
                    ) {
                    Log::do_log('notice',
                        "sympa::DoMessage(): Unable to send template '$result->{'tt2'}' to $sender"
                    );
                }
            } else {
                unless (
                    report::reject_report_msg(
                        'auth', $result->{'reason'},
                        $sender, {'message' => $message},
                        $robot, $msg_string,
                        $list
                    )
                    ) {
                    Log::do_log('notice',
                        "sympa::DoMessage(): Unable to send template 'message_report', type 'auth' to $sender"
                    );
                }
            }
        }
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $list->{'name'},
                'action'       => 'DoMessage',
                'parameters'   => "$which,$messageid,$robot",
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'rejected_authorization',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    } else {
        Log::do_log('err',
            'Unknown action %s returned by the scenario "send"', $action);
        report::reject_report_msg(
            'intern', 'Unknown action returned by the scenario "send"',
            $sender, {'msg_id' => $messageid, 'message' => $message},
            $robot, $msg_string,
            $list
        );
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $list->{'name'},
                'action'       => 'DoMessage',
                'parameters'   => "$which,$messageid,$robot",
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'internal',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }
}

############################################################
#  DoCommand
############################################################
#  Handles a command sent to the list manager.
#
# IN : -$rcpt : recepient | <listname>-<subscribe|unsubscribe>
#      -$robot (+): robot
#      -$message : ref(Message) with :
#        ->msg (+): ref(MIME::Entity) : message containing command
#        ->filename (+): file containing message
#
# OUT : $success
#     | undef
#
##############################################################
sub DoCommand {
    my ($rcpt, $robot, $message) = @_;
    my $msg  = $message->{'msg'};
    my $file = $message->{'filename'};
    Log::do_log('debug', '(%s %s %s %s)', $rcpt, $robot, $msg, $file);

    ## boolean
    my $cmd_found = 0;

    ## Now check if the sender is an authorized address.
    my $hdr = $msg->head;

    ## Decode headers
    #$hdr->decode();

    my $messageid = $hdr->get('Message-Id');
    my ($success, $status);

    Log::do_log(
        'debug',
        "Processing command with priority %s, %s",
        $Conf::Conf{'sympa_priority'}, $messageid
    );

    my $sender = $message->{'sender'};

    if ($message->{'spam_status'} eq 'spam') {
        Log::do_log(
            'notice',
            'Message for list %s@%s ignored, because tagged as spam (message ID: %s)',
            $rcpt,
            $robot,
            $messageid
        );
        return undef;
    }

    ## Detect loops
    if ($msgid_table{'sympa@' . $robot}{$messageid}) {
        Log::do_log('err',
            'Found known Message-ID, ignoring command which would cause a loop'
        );
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $rcpt,
                'action'       => 'DoCommand',
                'parameters'   => "$rcpt,$robot,$message",
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'known_message',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }    ## Clean old files from spool

    ## Keep track of known message IDs...if any
    $msgid_table{'sympa@' . $robot}{$messageid} = time
        if ($messageid);

    ## If X-Sympa-To = <listname>-<subscribe|unsubscribe> parse as a unique
    ## command
    if ($rcpt =~ /^(\S+)-(subscribe|unsubscribe)(\@(\S+))?$/o) {
        Log::do_log('debug', 'Processing message for %s-%s', $1, $2);
        my $auth_level;
        $auth_level = 'dkim'
            if $message->{'dkim_pass'
                }; # at this point $message->{'dkim_pass'} does not verify that Subject: is part of the signature. It SHOULD !
        Commands::parse($sender, $robot, "$2 $1", $auth_level, $message);
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $rcpt,
                'action'       => 'DoCommand',
                'parameters'   => "$rcpt,$robot,$message",
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'success',
                'error_type'   => '',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return 1;
    }

    ## Process the Subject of the message
    ## Search and process a command in the Subject field
    my $subject_field = $message->{'decoded_subject'};
    $subject_field = '' unless defined $subject_field;
    $subject_field =~ s/\n//mg;    ## multiline subjects
    my $re_regexp = Sympa::Regexps::re();
    $subject_field =~ s/^\s*(?:$re_regexp)?\s*(.*)\s*$/$1/i;

    my $auth_level = 'dkim' if ($message->{'dkim_pass'});
    $auth_level = $is_signed->{'subject'} if ($is_signed->{'subject'});

    $success ||= Commands::parse($sender, $robot, $subject_field, $auth_level,
        $message);

    unless ($success and $success eq 'unknown_cmd') {
        $cmd_found = 1;
    }

    ## Make multipart singlepart
    if ($msg->is_multipart()) {
        my $status = tools::as_singlepart($msg, 'text/plain');

        unless (defined $status) {
            Log::do_log('err', 'Could not change multipart to singlepart');
            report::global_report_cmd('user', 'error_content_type', {});
            Log::db_log(
                {   'robot'        => $robot,
                    'list'         => $rcpt,
                    'action'       => 'DoCommand',
                    'parameters'   => "$rcpt,$robot,$message",
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'error_content_type',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }

        if ($status) {
            Log::do_log('notice', 'Multipart message changed to singlepart');
        }
    }

    my $i;
    my $size;

    ## Process the body of the message
    ## unless subject contained commands or message has no body
    if ((!$cmd_found) && (defined $msg->bodyhandle)) {

        ## check Content-type
        my $mime         = $hdr->get('Mime-Version');
        my $content_type = $msg->effective_type;
        ## Get charset
        my $cset =
            MIME::Charset->new($hdr->mime_attr('Content-Type.Charset'));
        unless ($cset->decoder) {
            # Charset is unknown.  Detect 7-bit charset.
            my ($dummy, $charset) =
                MIME::Charset::body_encode($msg->bodyhandle->as_string,
                '', Detect7Bit => 'YES');
            $cset = MIME::Charset->new($charset);
        }
        if ($cset->decoder) {
            $cset->encoder('UTF-8');
        } else {
            $cset = MIME::Charset->new('US-ASCII');
        }

        unless (($content_type =~ /text/i and !$mime)
            or !($content_type)
            or ($content_type =~ /text\/plain/i)) {
            Log::do_log('err',
                "Ignoring message body not in text/plain, Content-type: %s",
                $content_type);
            report::global_report_cmd('user', 'error_content_type', {});
            Log::db_log(
                {   'robot'        => $robot,
                    'list'         => $rcpt,
                    'action'       => 'DoCommand',
                    'parameters'   => "$rcpt,$robot,$message",
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'error_content_type',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return $success;
        }

        my @body = $msg->bodyhandle->as_lines();
        foreach $i (@body) {
            $i = $cset->encode($i);

            last if ($i =~ /^-- $/);    ## ignore signature
            last if ($i =~ /^-- $/);    ## ignore signature
            $i =~ s/^\s*>?\s*(.*)\s*$/$1/g;
            next if ($i =~ /^$/);       ## skip empty lines
            next if ($i =~ /^\s*\#/);

            Log::do_log('debug2', 'Is_signed->body %s', $is_signed->{'body'});

            $auth_level = 'dkim' if ($message->{'dkim_pass'});
            $auth_level = $is_signed->{'body'} if ($is_signed->{'body'});
            $status =
                Commands::parse($sender, $robot, $i, $auth_level, $message);

            $cmd_found = 1;    # if problem no_cmd_understood is sent here
            if ($status eq 'unknown_cmd') {
                Log::do_log('notice', 'Unknown command found: %s', $i);
                report::reject_report_cmd('user', 'not_understood', {}, $i);
                Log::db_log(
                    {   'robot'        => $robot,
                        'list'         => $rcpt,
                        'action'       => 'DoCommand',
                        'parameters'   => "$rcpt,$robot,$message",
                        'target_email' => '',
                        'msg_id'       => $messageid,
                        'status'       => 'error',
                        'error_type'   => 'not_understood',
                        'user_email'   => $sender,
                        'client'       => $ip,
                        'daemon'       => $daemon_name
                    }
                );
                last;
            }
            if ($i =~ /^(quit|end|stop|-)\s*$/io) {
                last;
            }

            $success ||= $status;
        }
    }

    ## No command found
    unless ($cmd_found == 1) {
        Log::do_log('info', "No command found in message");
        report::global_report_cmd('user', 'no_cmd_found', {});
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $rcpt,
                'action'       => 'DoCommand',
                'parameters'   => "$rcpt,$robot,$message",
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'no_cmd_found',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    return $success;
}

############################################################
#  SendDigest
############################################################
#  Read the queuedigest and send old digests to the subscribers
#  with the digest option.
#
# IN : -
#
# OUT : -
#     | undef
#
##############################################################
sub SendDigest {
    Log::do_log('debug', '');

    if (!opendir(DIR, $Conf::Conf{'queuedigest'})) {
        die sprintf 'Unable to access directory %s : %s',
            $Conf::Conf{'queuedigest'}, $!;
        ## No return.
    }
    my @dfile = (sort grep (!/^\./, readdir(DIR)));
    closedir(DIR);

    foreach my $listaddress (@dfile) {

        my $filename = $Conf::Conf{'queuedigest'} . '/' . $listaddress;

        my ($listname, $robot) = split /\@/, $listaddress;
        my $list = List->new($listname, $robot);
        unless ($list) {
            Log::do_log('info',
                'Unknown list %s, (robot %s), deleting digest file %s',
                $filename, $listname, $robot);
            Log::db_log(
                {   'robot'        => $robot,
                    'list'         => $list->{'name'},
                    'action'       => 'SendDigest',
                    'parameters'   => "$filename",
                    'target_email' => '',
                    'msg_id'       => '',
                    'status'       => 'error',
                    'error_type'   => 'unknown_list',
                    'user_email'   => '',
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            unlink $filename;
            return undef;
        }

        $language->set_lang(
            $list->{'admin'}{'lang'},
            Conf::get_robot_conf($robot, 'lang'),
            $Conf::Conf{'lang'}, 'en'
        );

        if ($list->get_nextdigest()) {
            ## Blindly send the message to all users.
            Log::do_log('info', "Sending digest to list %s", $listaddress);
            my $start_time = time;
            $list->send_msg_digest();

            unlink($filename);
            Log::do_log('info', 'Digest of the list %s sent (%d seconds)',
                $listname, time - $start_time);
            Log::db_log(
                {   'robot'        => $robot,
                    'list'         => $list->{'name'},
                    'action'       => 'SendDigest',
                    'parameters'   => "",
                    'target_email' => '',
                    'msg_id'       => '',
                    'status'       => 'success',
                    'error_type'   => '',
                    'user_email'   => '',
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
        }
    }
}

## Cleanup the msgid_table every 'msgid_table_cleanup_frequency' sec
## Removes all entries older than 'msgid_table_cleanup_ttl' sec
sub clean_msgid_table {

    foreach my $rcpt (keys %msgid_table) {
        foreach my $msgid (keys %{$msgid_table{$rcpt}}) {
            if (time > $msgid_table{$rcpt}{$msgid} +
                $Conf::Conf{'msgid_table_cleanup_ttl'}) {
                delete $msgid_table{$rcpt}{$msgid};
            }
        }
    }

    return 1;
}

__END__

=encoding utf-8

=head1 NAME

sympa, sympa.pl - A Modern Mailing List Manager

=head1 SYNOPSIS

S<B<sympa.pl> [ B<-d, --debug> ] [ B<-f, --file>=I<another.sympa.conf> ]>
      S<[ B<-k, --keepcopy>=I<directory> ]>
      S<[ B<-l, --lang>=I<lang> ]> [ B<-m, --mail> ]
      S<[ B<-h, --help> ]> [ B<-v, --version> ]
      S<>
      S<[ B<--import>=I<listname> ]>
      S<[ B<--close_list>=I<list[@robot]> ]>
      S<[ B<--purge_list>=I<list[@robot]> ]>
      S<[ B<--lowercase> ] [ B<--make_alias_file> ]>
      S<[ B<--dump>=I<listname> | ALL ]>

=head1 DESCRIPTION

B<Sympa> is scalable and highly customizable mailing list manager. 
It can cope with big lists (200,000 subscribers) and comes with 
a complete (user and admin) Web interface. It is 
internationalized, and supports the us, fr, de, es, it, fi, and 
chinese locales. A scripting language allows you to extend the 
behavior of commands. B<Sympa> can be linked to an LDAP directory 
or an RDBMS to create dynamic mailing lists. B<Sympa> provides S/MIME 
and HTTPS based authentication and encryption.
Sympa is a modern mailing-list manager. It supports a lot of useful
features.

=head1 OPTIONS

F<sympa.pl> may run with following options in general.

=over 4

=item B<-d>, B<--debug>

Enable debug mode.

=item B<-f>, B<--config=>I<file>

Force Sympa to use an alternative configuration file instead
of F<--CONFIG-->.

=item B<-l>, B<--lang=>I<lang>

Set this option to use a language for Sympa. The corresponding
gettext catalog file must be located in F<--localedir-->
directory.

=item B<--log_level=>I<level>

Sets Sympa log level.

=back

F<sympa.pl> may run in daemon mode with following options.

=over 4

=item B<--foreground>

The process remains attached to the TTY.

=item B<-k>, B<--keepcopy=>F<directory>

This option tells Sympa to keep a copy of every incoming message, 
instead of deleting them. `directory' is the directory to 
store messages.

=item B<-m>, B<--mail>

Sympa will log calls to sendmail, including recipients. This option is
useful for keeping track of each mail sent (log files may grow faster
though).

=begin comment

=item B<--service=process_command>|B<process_message>|B<process_creation>

Process is dedicated to messages distribution, commands or to automatic lists
creation (default three of them).

B<Not implemented>.

=end comment

=back

With the following options F<sympa.pl> will run in batch mode:

=over 4

=item B<--add_list=>I<family_name> B<--robot=>I<robot_name>
    B<--input_file=>I</path/to/file.xml>

Add the list described by the file.xml under robot_name, to the family
family_name.

=item B<--change_user_email> B<--current_email=>I<xx> B<--new_email=>I<xx>

Changes a user email address in all Sympa  databases (subscriber_table,
list config, etc) for all virtual robots.

=item B<--close_family=>I<family_name> B<--robot=>I<robot_name>

Close lists of family_name family under robot_name.      

=item B<--close_list=>I<list[@robot]>

Close the list (changing its status to closed), remove aliases and remove
subscribers from DB (a dump is created in the list directory to allow
restoring the list)

=item B<--conf_2_db>

Load sympa.conf and each robot.conf into database.

=item B<--create_list> B<--robot=>I<robot_name>
    B<--input_file=>I</path/to/file.xml >

Create a list with the XML file under robot robot_name.

=item B<--dump=>I<list>@I<dom>|C<ALL>

Dumps subscribers of for `listname' list or all lists. Subscribers are 
dumped in subscribers.db.dump.

=begin comment

=item B<--export_list> [B<--robot=>I<robot_name>]

B<Not fully implemented>.

=end comment

=item B<--health_check>

Check if F<sympa.conf>, F<robot.conf> of virtual robots and database structure
are correct.  If any errors occur, exits with non-zero status.

=item B<--import=>I<list>@I<dom>

Import subscribers in the list. Data are read from standard input.
The imported data should contain one entry per line : the first field
is an email address, the second (optional) field is the free form name.
Fields are spaces-separated.

Sample:

    ## Data to be imported
    ## email        gecos
    john.steward@some.company.com           John - accountant
    mary.blacksmith@another.company.com     Mary - secretary

=item B<--instantiate_family=>I<family_name> B<--robot=>I<robot_name>
    B<--input_file=>I</path/to/file.xml> [B<--close_unknown>] [B<--quiet>]

Instantiate family_name lists described in the file.xml under robot_name.
The family directory must exist; automatically close undefined lists in a
new instantiation if --close_unknown is specified; do not print report if
C<--quiet> is specified.

=item B<--lowercase>

Lowercases email addresses in database.

=item B<--make_alias_file>

Create an aliases file in /tmp/ with all list aliases. It uses the
F<list_aliases.tt2> template  (useful when list_aliases.tt2 was changed).

=item B<--md5_encode_password>

Rewrite password in C<user_table> of database using MD5 fingerprint.
YOU CAN'T UNDO unless you save this table first.

=item B<--modify_list=>I<family_name> B<--robot=>I<robot_name>
    B<--input_file=>I</path/to/file.xml>

Modify the existing list installed under the robot robot_name and that
belongs to the family family_name. The new description is in the C<file.xml>.

=item B<--purge_list>=I<list>[@I<robot>]

Remove the list (remove archive, configuration files, users and owners in admin table. Restore is not possible after this operation.

=item B<--reload_list_config>
    [B<--list=>I<mylist>@I<mydom>] [B<--robot=>I<mydom>]

Recreates all F<config.bin> files or cache in C<list_table>.
You should run this command if you edit authorization scenarios.
The list and robot parameters are optional.

=item B<--rename_list=>I<listname>@I<robot>
    B<--new_listname=>I<newlistname> B<--new_listrobot=>I<newrobot>

Renames a list or move it to another virtual robot.

=item B<--sync_include=>I<listname>@I<robot>

Trigger the list members update.

=begin comment

=item B<--sync_list_db>

B<Deprecated>.  Use B<--reload_list_config>.

=end comment

=item B<--test_database_message_buffer>

Test the database message buffer size.

=item B<--upgrade> [B<--from=>I<X>] [B<--to=>I<Y>]

Runs Sympa maintenance script to upgrade from version I<X> to version I<Y>.

=item B<--upgrade_shared> [B<--list=>I<X>] [B<--robot=>I<Y>]>

Rename files in shared.

=back

With following options F<sympa.pl> will print some information and exit.

=over 4

=item B<-h>, B<--help>

Print this help message.

=item B<--md5_digest=>I<password>

Output a MD5 digest of a password (useful for SOAP client trusted
application).

=item B<-v>, B<--version>

Print the version number.

=back

=head1 FILES

F<--CONFIG--> main configuration file.

F<--piddir--/sympa.pid> this file contains the process ID
of F<sympa.pl>.

=head1 AVAILABILITY

Latest version of B<Sympa> is available from L<http://www.sympa.org/>.

=head1 MORE DOCUMENTATION

The full documentation in HTML and PDF formats can be
found in L<http://www.sympa.org/manual/>.

The mailing lists (with web archives) can be accessed at
L<http://listes.renater.fr/sympa/lists/informatique/sympa>.

=head1 HISTORY

This program was originally written by:

=over 4

=item Serge Aumont

ComitE<233> RE<233>seau des UniversitE<233>s

=item Olivier SalaE<252>n

ComitE<233> RE<233>seau des UniversitE<233>s

=back

=head1 BUGS

Report bugs to Sympa bug tracker.
See L<http://www.sympa.org/tracking>.

=head1 SEE ALSO

L<sympa.conf(5)>, L<sympa_wizard(1)>.

L<archived(8)>, L<bulk(8)>, L<bounced(8)>, L<spooler(8)>, L<task_manager(8)>.

L<sendmail(8)>, L<alias_manager(8)>.

L<wwsympa(8)>, L<sympa_soap_server(8)>.

=cut
