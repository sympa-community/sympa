#!--PERL--
# -*- indent-tabs-mode: nil; -*-
# vim:ft=perl:et:sw=4
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
#
# Copyright (c) 1997, 1998, 1999 Institut Pasteur & Christophe Wolfhugel
# Copyright (c) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
# 2006, 2007, 2008, 2009, 2010, 2011 Comite Reseau des Universites
# Copyright (c) 2011, 2012, 2013, 2014 GIP RENATER
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

## Options :  F         -> do not detach TTY
##         :  d		-> debug -d is equiv to -dF
## Now, it is impossible to use -dF but you have to write it -d -F

use lib split(/:/, $ENV{SYMPALIB} || ''), '--modulesdir--';
use strict;
use warnings;
use Digest::MD5 qw();
use Getopt::Long;
use Pod::Usage;
use POSIX qw();

use Conf;
use Sympa::Constants;
use Sympa::Crash;    # Show traceback.
use Sympa::Language;
use List;
use Log;
use mail;
use Message;
use Sympa::Regexps;
use SDM;
use tools;

my $daemon_name = Log::set_daemon($0);
my $ip          = $ENV{'REMOTE_HOST'};

#getopts('dF');

## Check options
my %options;
unless (
    GetOptions(
        \%main::options, 'config|f=s',  'debug|d', 'help|h',
        'foreground|F',  'log_level=s', 'version|v'
    )
    ) {
    pod2usage(-exitval => 1, -output => \*STDERR);
}

if ($main::options{'help'}) {
    pod2usage(0);
} elsif ($main::options{'version'}) {
    printf "Sympa %s\n", Sympa::Constants::VERSION;
    exit 0;
}

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless ($main::options{'log_level'});
}
$main::options{'foreground'} = 1 if ($main::options{'debug'});
$main::options{'log_to_stderr'} = 1
    if ($main::options{'debug'} || $main::options{'foreground'});

# Load sympa.conf
unless (Conf::load()) {
    printf STDERR
        "Unable to load sympa configuration, file %s has errors.\n",
        Conf::get_sympa_conf();
    exit 1;
}

## Check databse connectivity
unless (SDM::check_db_connect()) {
    Log::fatal_err(
        'Database %s defined in sympa.conf has not the right structure or is unreachable.',
        $Conf::Conf{'db_name'}
    );
}

## Put ourselves in background if not in debug mode.
unless ($main::options{'debug'} || $main::options{'foreground'}) {
    open(STDERR, ">> /dev/null");
    open(STDOUT, ">> /dev/null");
    if (open(TTY, "/dev/tty")) {
        # ioctl(TTY, TIOCNOTTY(), 0);
        ioctl(TTY, 0x20007471, 0);    # XXX s/b TIOCNOTTY
        close(TTY);
    }
    setpgrp(0, 0);
    if ((my $child_pid = fork) != 0) {
        print STDOUT "Starting archive daemon, pid $_\n";

        exit(0);
    }
}

## If process is running in foreground, don't write STDERR to a dedicated file
my $options;
$options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});

## Create and write the PID file
tools::write_pid('archived', $$, $options);
unless ($options->{'stderr_to_tty'}) {
    tools::direct_stderr_to_file(('pid' => $$));
}

# setting log_level using conf unless it is set by calling option
if ($main::options{'log_level'}) {
    Log::set_log_level($main::options{'log_level'});
    Log::do_log('info',
        "Configuration file read, log level set using options : $main::options{'log_level'}"
    );
} else {
    Log::set_log_level($Conf::Conf{'log_level'});
    Log::do_log('info',
        "Configuration file read, default log level $Conf::Conf{'log_level'}"
    );
}

my $log_facility = $Conf::Conf{'log_facility'} || $Conf::Conf{'syslog'};
Log::do_openlog($log_facility, $Conf::Conf{'log_socket_type'}, 'archived');

## Set the User ID & Group ID for the process
$( = $) = (getgrnam(Sympa::Constants::GROUP))[2];
$< = $> = (getpwnam(Sympa::Constants::USER))[2];

## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (useful on OS X)
unless (($( == (getgrnam(Sympa::Constants::GROUP))[2])
    && ($< == (getpwnam(Sympa::Constants::USER))[2])) {
    Log::fatal_err(
        "Failed to change process user ID and group ID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via sudo."
    );
}

## Sets the UMASK
umask(oct($Conf::Conf{'umask'}));

foreach my $robot (@{Conf::get_robots_list()}) {
    my $arc_dir = Conf::get_robot_conf($robot, 'arc_path');
    ## Create arc_path if required
    if ($arc_dir) {
        unless (directory_check($arc_dir)) {
            Log::do_log('err',
                'No vailable directory to store archives. Exiting');
            exit -1;
        }
    } else {
        Log::do_log('err',
            'Robot %s has no archives directory. Check arc_path parameter in this robot.conf and in wwsympa.conf.'
        );
        exit -1;
    }
}

## Change to list root
unless (chdir($Conf::Conf{'home'})) {
    die sprintf 'Unable to change directory to %s: %s', $Conf::Conf{'home'},
        $!;
}

Sympa::Language->instance->set_lang($Conf::Conf{'lang'}, 'en');

Log::do_log('notice', 'Archived %s Started', Sympa::Constants::VERSION);

## Catch signals, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
$SIG{'INT'}  = \&sigterm;
my $end = 0;

my $queue = $Conf::Conf{'queueoutgoing'};
print "queue : $queue\n";

## infinite loop scanning the queue (unless a sig TERM is received
while (!$end) {

    List::init_list_cache();
    # Process grouped notifications
    List::send_notify_to_listmaster(undef, undef, undef, 1);

    unless (opendir(DIR, $queue)) {
        die sprintf 'Can\'t open dir %s: %s', $queue, $!;
        ## No return.
    }

    my @files =
        sort grep {/(^[^\.]|^\.(remove|rebuild)\.(.*))/} readdir DIR;
    closedir DIR;

    ## this sleep is important to be raisonably sure that sympa is not
    ## currently
    ## writting the file this deamon is openning.
    sleep 6;

    foreach my $file (@files) {

        last if $end;
        next unless (-f "$queue/$file");

        next if $file =~ /\.LOCK\z/;    # Skip lock.

        if ($file =~ /^\.remove\.((.*)\.(\d\d\d\d\-\d\d))\.\d+$/) {
            my $arclistdir = $1;
            my $listname   = $2;
            my $yyyymm     = $3;
            ##my $arcpath = "$arcpath/$listname/$yyyymm";

            my $list;
            unless ($list = List->new($listname)) {
                Log::do_log('err', 'Unknown list %s', $listname);
                next;
            }
            my $arcpath =
                Conf::get_robot_conf($list->{'domain'}, 'arc_path')
                . "/$listname/$yyyymm";

            Log::do_log('debug',
                "start remove process :listname :'$listname' arclistdir '$arclistdir' arcpath '$arcpath'  yyyymm '$yyyymm'"
            );

            Log::do_log('debug', 'Remove found: %s for list %s',
                $file, $yyyymm);

            unless (open REMOVE, "$queue/$file") {
                Log::do_log('err',
                    "Ignoring file $queue/$file because couldn't read it, archived.pl must use the same uid as sympa"
                );
                next;
            }

            my $email_regexp = Sympa::Regexps::email();

            foreach my $order (<REMOVE>) {
                unless ($order =~ /(.*)\|\|($email_regexp)/) {
                    Log::do_log('err',
                        'Ignoring remove_order %s not recognized format',
                        $order);
                    next;
                }
                my $msgid  = $1;
                my $sender = $2;

                chomp $msgid;
                if ($msgid =~ /NO-ID-FOUND\.mhonarc\.org/) {
                    Log::do_log('err', 'No message id found');
                    next;
                }

                my $message;
                unless ($message =
                    Sympa::Archive::search_msgid("$arcpath/arctxt", $msgid)) {
                    Log::do_log('err',
                        'No message with message ID %s found in %s/arctxt',
                        $msgid, $arcpath);
                    next;
                }

                unless ($list->am_i('privileged_owner', $sender)
                    || $list->am_i('owner',  $sender)
                    || $list->am_i('editor', $sender)
                    || List::is_listmaster($sender, $list->{'domain'})) {
                    # if not list owner or list editor or listmaster,n check
                    # if sender of remove order is sender of the message to
                    # remove

                    my $new_message;
                    unless (
                        $new_message = Message->new(
                            {   'file'       => "$arcpath/arctxt/$message",
                                'noxsympato' => 'noxsympato'
                            }
                        )
                        ) {
                        Log::do_log('err',
                            "unable to load new message $arcpath/arctxt/$message"
                        );
                        next;
                    }
                    my $messagesender = lc($new_message->{'sender'});

                    unless ($sender eq $messagesender) {
                        Log::do_log('err',
                            'Remove command by unauthorized sender');
                        next;
                    }
                }
                # this point : requested command is from a authorized personn
                # (message sender or list admin or listmaster

                remove($arclistdir, $msgid);

                my $url_dir = $list->{'dir'} . '/urlized/' . $msgid;
                tools::remove_dir($url_dir);

                unless (-d "$arcpath/deleted") {
                    unless (mkdir("$arcpath/deleted", 0777)) {
                        Log::do_log('info',
                            "remove_arc: unable to create $arcpath/deleted : $!"
                        );
                        last;
                    }
                }

                unless (
                    rename(
                        "$arcpath/arctxt/$message",
                        "$arcpath/deleted/$message"
                    )
                    ) {
                    Log::do_log('info',
                        "remove_arc: unable to rename message $arcpath/arctxt/$message"
                    );
                    next;
                }

                # remove directory if empty arctxt
                unless (opendir(DIR, "$arcpath/arctxt")) {
                    Log::do_log('info', 'Unable to open dir %s/arctxt',
                        $arcpath);
                    next;
                }
                my @files = grep(/^\d+$/, readdir(DIR));
                closedir(DIR);
                if ($#files == -1) {
                    tools::remove_dir($arcpath);
                } else {
                }
            }
            close REMOVE;

            unless (unlink("$queue/$file")) {
                Log::do_log('err',
                    "Ignoring file $queue/$file because couldn't remove it, archived.pl must use the same uid as sympa"
                );
                next;
            }

        } elsif ($file =~ /^\.rebuild\.(.*)$/) {
            Log::do_log('debug', 'Rebuild found: %s for list %s', $file, $1);
            rebuild($1);
            unless (unlink("$queue/$file")) {
                Log::do_log('err',
                    "Ignoring file $queue/$file because couldn't remove it, archived.pl must use the same uid as sympa"
                );
                next;
            }
        } else {
            my ($yyyy, $mm, $dd, $hh, $min, $ss, $adrlist);

            if ($file =~
                /^(\d{4})-(\d{2})-(\d{2})-(\d{2})-(\d{2})-(\d{2})-(.*)$/) {
                ($yyyy, $mm, $dd, $hh, $min, $ss, $adrlist) =
                    ($1, $2, $3, $4, $5, $6, $7);
            } elsif (($file =~ /^(.*)\.(\d+)\.(\d+)\.(\d+)$/)
                || ($file =~ /^(.*)\.(\d+)\.(\d+)$/)) {
                $adrlist = $1;
                my $date = $2;

                my @now = localtime($date);
                $yyyy = sprintf '%04d', 1900 + $now[5];
                $mm   = sprintf '%02d', $now[4] + 1;
                $dd   = sprintf '%02d', $now[3];
                $hh   = sprintf '%02d', $now[2];
                $min  = sprintf '%02d', $now[1];
                $ss   = sprintf '%02d', $now[0];

            } else {
                Log::do_log('err',
                    "Ignoring file $queue/$file because not to be rebuid or liste archive"
                );
                unlink("$queue/$file");
                next;
            }

            my ($listname, $hostname);
            if ($adrlist =~ /^(.*)\@(.*)$/) {
                $listname = $1;
                $hostname = $2;
            } else {
                Log::do_log('err', 'Match of list address "%s" failed',
                    $adrlist);
                return undef;
            }

            Log::do_log('notice', 'Archiving %s for list %s', $file,
                $adrlist);
            unless (
                mail2arc(
                    $file, $listname, $hostname, $yyyy, $mm,
                    $dd,   $hh,       $min,      $ss
                )
                ) {
                tools::save_to_bad(
                    {   'file'     => $file,
                        'hostname' => $hostname,
                        'queue'    => $queue,
                    }
                );
                List::send_notify_to_listmaster('archiving_failed', $hostname,
                    {'file' => "$file", 'bad' => "$queue/bad"});
            }
            if (-f "$queue/$file") {
                unless (unlink("$queue/$file")) {
                    Log::do_log('err',
                        "Ignoring file $queue/$file because couldn't remove it, archived.pl must use the same uid as sympa"
                    );
                    Log::do_log('err',
                        "exiting because I don't want to loop until file system is full"
                    );
                    last;
                }
            }
        }
    }
    ## Free zombie sendmail processes
    mail::reaper();
}

# Purge grouped notifications
List::send_notify_to_listmaster(undef, undef, undef, undef, 1);

Log::do_log('notice', 'Archived exited normally due to signal');
tools::remove_pid('archived', $$);

exit(0);

## When we catch signal, just change the value of the loop
## variable.
sub sigterm {
    $end = 1;
}

# Removes the message having the identifier $msgid from the list named
# $adrlist.
#* $adrlist, a character string containing the list name.
#* $msgid, a character string containing the message identifier.
sub remove {
    my $adrlist = shift;
    my $msgid   = shift;
    my $robot   = shift;

    Log::do_log('debug2', '(%s, %s)', $adrlist, $msgid);
    my $arc;

    if ($adrlist =~ /^(.*)\.(\d{4}-\d{2})$/) {
        $adrlist = $1;
        $arc     = $2;
    }

    Log::do_log('notice', 'Removing %s in list %s section %s',
        $msgid, $adrlist, $2);

    Log::db_stat_log(
        {   'robot'     => $robot,
            'list'      => $adrlist,
            'operation' => 'remove archive',
            'parameter' => '',
            'mail'      => 'test@cru.fr',
            'client'    => $ip,
            'daemon'    => $daemon_name
        }
    );

    unless (
        Log::db_log(
            {   'robot'        => $robot,
                'list'         => $adrlist,
                'action'       => 'remove',
                'parameters'   => $msgid . ',' . $adrlist,
                'target_email' => '',
                'msg_id'       => $msgid,
                'status'       => 'succes',
                'error_type'   => '',
                'user_email'   => '',
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        )
        ) {
        Log::do_log('error', 'Unable to log event');
    }
    my $arcpath = Conf::get_robot_conf($robot, 'arc_path');
    $arc =~ /^(\d{4})-(\d{2})$/;
    my $yyyy = $1;
    my $mm   = $2;

    system(
        Conf::get_robot_conf($robot, 'mhonarc'),
        '-outdir' => "$arcpath/$adrlist/$yyyy-$mm",
        '-rmm'    => $msgid
    );
}

# Rebuilds archives for the list the name of which is given in the argument
# $adrlist.
# * $adrlist, a character string containing the name of the list the archives
#   of which we want to rebuild.
# Returns undef if something goes wrong.
sub rebuild {

    my $adrlist = shift;
    my $arc;

    Log::do_log('debug2', '(%s)', $adrlist);

    if ($adrlist =~ /^(.*)\.(\d{4}-\d{2})$/) {
        $adrlist = $1;
        $arc     = $2;
    }

    my ($listname, $hostname);
    if ($adrlist =~ /^(.*)\@(.*)$/) {
        $listname = $1;
        $hostname = $2;
    } else {
        Log::do_log('err', 'Match of list address "%s" failed', $adrlist);
        return undef;
    }

    my $list    = List->new($listname, $hostname);
    my $robot   = $list->{'domain'};
    my $arcpath = Conf::get_robot_conf($robot, 'arc_path');
    Log::do_log('debug3', "Rebuilding %s archive (%s)", $adrlist, $2);

    my $tag = Sympa::Archive::get_tag($list);

    my $mhonarc_ressources =
        tools::search_fullpath($list, 'mhonarc-ressources.tt2');

    if (   ($list->{'admin'}{'web_archive_spam_protection'} ne 'none')
        && ($list->{'admin'}{'web_archive_spam_protection'} ne 'cookie')) {
        set_hidden_mode($tag);
    } else {
        unset_hidden_mode();
    }

    Log::do_log('notice', 'Rebuilding %s with M2H_ADDRESSMODIFYCODE: %s',
        $arc, $ENV{'M2H_ADDRESSMODIFYCODE'});

    if ($arc) {
        Log::do_log('notice', "Rebuilding %s of %s archive", $arc, $adrlist);
        $arc =~ /^(\d{4})-(\d{2})$/;
        my $yyyy = $1;
        my $mm   = $2;

        # remove empty directory
        my $arcdir = $arcpath . '/' . $adrlist . '/' . $yyyy . '-' . $mm;
        my $arctxt = $arcdir . '/arctxt';
        if (opendir(DIR, $arctxt)) {
            my @files = (grep(/^\d+$/, (readdir DIR)));
            close(DIR);
            if ($#files == -1) {
                Log::do_log('notice', "Removing empty directory %s", $arcdir);
                tools::remove_dir($arcdir);
                next;
            }

            ## index file was removed ; recreate it
            my $index = $files[$#files];
            save_idx($arcdir . '/index', $index + 1);
        }

        ## recreate index file if needed
        unless (-f $arcdir . '/index') {
            create_idx($arcdir);
        }

        ## Remove .mhonarc.db
        unlink $arcpath . '/' . $adrlist . '/' . $yyyy . '-' . $mm
            . '/.mhonarc.db';

        ## Remove existing HTML files
        opendir HTML, "$arcpath/$adrlist/$yyyy-$mm";

        ## Skip arctxt/ . and ..
        foreach my $html_file (grep !/^arctxt$|^index$|\.+$/, readdir(HTML)) {
            unlink $arcpath . '/' . $adrlist . '/' . $yyyy . '-' . $mm . '/'
                . $html_file;
        }
        closedir HTML;

        my $arcs_dir = Sympa::Archive::clean_archive_directory($robot,
            "/$adrlist/$arc/arctxt");
        my $dir_to_rebuild = $arcs_dir->{'dir_to_rebuild'} if ($arcs_dir);

        my @cmd = (
            Conf::get_robot_conf($robot, 'mhonarc'),
            '-modifybodyaddresses',
            '-addressmodifycode' => $ENV{'M2H_ADDRESSMODIFYCODE'},
            '-rcfile'            => $mhonarc_ressources,
            '-outdir'            => "$arcpath/$adrlist/$yyyy-$mm",
            '-definevars'        => sprintf(
                "listname='%s' hostname=%s yyyy=%s mois=%s yyyymm=%s-%s wdir=%s base=%s/arc tag=%s",
                $listname, $hostname, $yyyy, $mm, $yyyy, $mm, $arcpath,
                Conf::get_robot_conf($robot, 'wwsympa_url'), $tag
            ),
            '-umask' => $Conf::Conf{'umask'},
            $dir_to_rebuild
        );

        Log::do_log('debug', 'System call: %s', join(' ', @cmd));
        my $exitcode = system(@cmd) >> 8;

        # Delete temporary directory containing files with escaped HTML.
        if ($arcs_dir && -d $arcs_dir->{'cleaned_dir'}) {
            tools::del_dir($arcs_dir->{'cleaned_dir'});
        }

        ## Remove lock if required
        if ($exitcode == 75) {
            Log::do_log(
                'notice',
                'Removing lock directory %s',
                $arcpath . '/' . $adrlist . '/' . $arc . '/.mhonarc.lck'
            );
            rmdir $arcpath . '/' . $adrlist . '/' . $arc . '/.mhonarc.lck';

            $exitcode = system(@cmd) >> 8;
        }

        if ($exitcode) {
            Log::do_log(
                'err',
                'Command %s failed with exit code %s',
                join(' ', @cmd), $exitcode
            );
        }
    } else {
        Log::do_log('notice', 'Rebuilding %s archive completely', $adrlist);

        if (!opendir(DIR, "$arcpath/$adrlist")) {
            Log::do_log('err', 'Unable to open %s/%s to rebuild archive',
                $arcpath, $adrlist);
            return;
        }
        my @archives = (grep (/^\d{4}-\d{2}/, readdir(DIR)));
        close DIR;

        foreach my $arc (@archives) {
            $arc =~ /^(\d{4})-(\d{2})$/;
            my $yyyy = $1;
            my $mm   = $2;

            my $arcdir = $arcpath . '/' . $adrlist . '/' . $yyyy . '-' . $mm;

            ## Remove .mhonarc.db
            unlink $arcdir . '/.mhonarc.db';

            ## Remove existing HTML files
            opendir HTML, $arcdir;
            ## Skip arctxt/ . and ..
            foreach
                my $html_file (grep !/^arctxt$|^index$|\.+$/, readdir(HTML)) {
                unlink $arcdir . '/' . $html_file;
            }
            closedir HTML;
            my $dir_to_rebuild = $arcpath . "/$adrlist/$arc/arctxt";
            my $arcs_dir = Sympa::Archive::clean_archive_directory($robot,
                "/$adrlist/$arc/arctxt");
            if ($arcs_dir) {
                $dir_to_rebuild = $arcs_dir->{'dir_to_rebuild'};
            }
            ## recreate index file if needed
            unless (-f $arcdir . '/index') {
                create_idx($arcdir);
            }

            my @cmd = (
                Conf::get_robot_conf($robot, 'mhonarc'),
                '-modifybodyaddresses',
                '-addressmodifycode' => $ENV{'M2H_ADDRESSMODIFYCODE'},
                '-rcfile'            => $mhonarc_ressources,
                '-outdir'            => $arcdir,
                '-definevars'        => sprintf(
                    "listname='%s' hostname=%s yyyy=%s mois=%s yyyymm=%s-%s wdir=%s base=%s/arc tag=%s",
                    $listname, $hostname, $yyyy, $mm, $yyyy, $mm, $arcpath,
                    Conf::get_robot_conf($robot, 'wwsympa_url'), $tag
                ),
                '-umask' => $Conf::Conf{'umask'},
                $dir_to_rebuild
            );
            my $exitcode = system(@cmd) >> 8;

            # Delete temporary directory containing files with escaped HTML.
            if ($arcs_dir && -d $arcs_dir->{'cleaned_dir'}) {
                tools::del_dir($arcs_dir->{'cleaned_dir'});
            }

            ## Remove lock if required
            if ($exitcode == 75) {
                Log::do_log(
                    'notice',
                    'Removing lock directory %s',
                    $arcdir . '/.mhonarc.lck'
                );
                rmdir $arcdir . '/.mhonarc.lck';

                $exitcode = system(@cmd) >> 8;
            }
            if ($exitcode) {
                Log::do_log(
                    'err',
                    'Command %s failed with exit code %s',
                    join(' ', @cmd), $exitcode
                );
            }

        }
    }
}

# Archives one message into one list archives directory.
# * $file: a character string containing the message filename.
# * $listname: a character string containing the name of the list in which to
#   archive the message
# * $robot: a character string containing the name of the virtual robot
#   hosting the list.
# * $yyyy: a character string containing the year of the date when the message
#   is archived (i.e. now)
# * $mm: a character string containing the month of the date when the message
#   is archived (i.e. now)
# * $dd: a character string containing the day of the date when the message is
#   archived (i.e. now)
# * $hh: a character string containing the hour of the date when the message
#   is archived (i.e. now)
# * $min: a character string containing the minute of the date when the
#   message is archived (i.e. now)
# * $ss: a character string containing the second of the date when the message
#   is archived (i.e. now)
# Returns undef if something goes wrong.
sub mail2arc {
    my ($file, $listname, $robot, $yyyy, $mm, $dd, $hh, $min, $ss) = @_;
    my $newfile;

    my $list = List->new($listname, $robot);
    my $arcpath = Conf::get_robot_conf($list->{'domain'}, 'arc_path');
    unless (defined $list) {
        Log::do_log('err', 'Unknown list %s@%s', $listname, $robot);
        return undef;
    }

    my $tag = Sympa::Archive::get_tag($list);

    if (   ($list->{'admin'}{'web_archive_spam_protection'} ne 'none')
        && ($list->{'admin'}{'web_archive_spam_protection'} ne 'cookie')) {
        set_hidden_mode($tag);
    } else {
        unset_hidden_mode();
    }

    Log::do_log('debug', '%s for %s yyyy:%s, mm:%s dd:%s hh:%s min:%s ss:%s',
        $file, $list->get_list_id(), $yyyy, $mm, $dd, $hh, $min, $ss);
    #    chdir($arcpath);

    if ($Conf::Conf{'custom_archiver'}) {
        `$Conf::Conf{'custom_archiver'} --list=$listname\@$robot --file=$queue/$file`;
        return 1;
    } else {

        my $basedir = $arcpath . '/' . $list->get_list_id();

        if (!-d $basedir) {
            unless (mkdir $basedir, 0775) {
                Log::do_log('err', 'Cannot create directory %s', $basedir);
                List::send_notify_to_listmaster('unable_to_create_dir',
                    $robot, {'dir' => "$basedir"});
            }
            Log::do_log('debug', 'mkdir %s', $basedir);
        }

        ## Check quota
        if ($list->{'admin'}{'web_archive'}{'quota'}) {
            my $used = $list->get_arc_size("$arcpath");

            if ($used >= $list->{'admin'}{'web_archive'}{'quota'} * 1024) {
                Log::do_log('err',
                    "archived::mail2arc : web_arc Quota exceeded for list $list->{'name'}"
                );
                $list->send_notify_to_owner('arc_quota_exceeded',
                    {'size' => $used});
                return undef;
            }
            if ($used >=
                ($list->{'admin'}{'web_archive'}{'quota'} * 1024 * 0.95)) {
                Log::do_log('err',
                    "archived::mail2arc : web_arc Quota exceeded for list $list->{'name'}"
                );
                $list->send_notify_to_owner(
                    'arc_quota_95',
                    {   'size' => $used,
                        'rate' => int(
                            $used * 100 / (
                                $list->{'admin'}{'web_archive'}{'quota'} *
                                    1024
                            )
                        )
                    }
                );
            }
        }

        my $monthdir = $basedir . "/$yyyy-$mm";

        if (!-d $monthdir) {
            unless (mkdir($monthdir, 0775)) {
                Log::do_log('err', 'Cannot create directory %s', $monthdir);
                return undef;
            }

            Log::do_log('debug', 'mkdir %s/%s/%s-%s',
                $arcpath, $list->get_list_id(), $yyyy, $mm);

            if ($list->{'admin'}{'web_archive'}{'max_month'}) {
                # maybe need to remove some old archive
                if (opendir DIR, $arcpath . '/' . $list->get_list_id()) {
                    my @archives = (
                        sort { $a cmp $b }
                        grep (/^\d{4}-\d{2}/, readdir(DIR))
                    );
                    closedir DIR;
                    my $nb_month = $#archives + 1;
                    my $i        = 0;
                    while ($nb_month >
                        $list->{'admin'}{'web_archive'}{'max_month'}) {
                        Log::do_log('info', 'Removing %s/%s/%s',
                            $arcpath, $list->get_list_id(), $archives[$i]);
                        tools::remove_dir($arcpath . '/'
                                . $list->get_list_id() . '/'
                                . $archives[$i]);
                        $i++;
                        $nb_month--;
                    }
                }
            }
        }

        my $arctxtdir = $monthdir . "/arctxt";

        if (!-d $arctxtdir) {
            unless (mkdir($arctxtdir, 0775)) {
                Log::do_log('err', 'Cannot create directory %s', $arctxtdir);
                return undef;
            }
            Log::do_log('debug', 'mkdir %s', $arctxtdir);
        }

        ## copy the file in the arctxt and in "mhonarc -add"
        if (-f $monthdir . "/index") {
            open IDX, '<', "$monthdir/index"
                or die sprintf "Couldn't read index for %s: %s/n", $listname,
                $!;
            $newfile = <IDX>;
            chomp($newfile);
            $newfile++;
            close IDX;
        } else {
            ## recreate index file if needed and update it
            $newfile = create_idx($monthdir) + 1;
        }

        # savee arctxt dump of original message.
        my $output = $Conf::Conf{'tmpdir'} . '/arc' . $newfile;
        open ORIG, '<', "$queue/$file"
            or die sprintf 'Couldn\'t open file %s/%s: %s', $queue, $file,
            $!;
        open DUMP, '>', "$arctxtdir/$newfile"
            or die sprintf 'Couldn\'t open file %s/%s: %s', $arctxtdir,
            $newfile, $!;
        print DUMP join('', <ORIG>);
        close ORIG;
        close DUMP;

        # prepare a temporary file with clean message content (htlm parts are
        # cleaned)
        my $safe = Sympa::Archive::clean_archived_message($robot,
            "$arctxtdir/$newfile", $output);
        unless ($safe) {
            Log::do_log('err', "Could not clean message, ignoring message");
            next;
        }

        my $mhonarc_ressources =
            tools::search_fullpath($list, 'mhonarc-ressources.tt2');

        Log::do_log(
            'debug',
            'Calling %s for list %s',
            Conf::get_robot_conf($robot, 'mhonarc'), $list
        );

        # call mhonarc on cleaned message source to make clean htlm view of
        # message
        my @cmd = (
            Conf::get_robot_conf($robot, 'mhonarc'),
            '-add',
            '-modifybodyaddresses',
            '-addressmodifycode' => $ENV{'M2H_ADDRESSMODIFYCODE'},
            '-rcfile'            => $mhonarc_ressources,
            '-outdir'            => $monthdir,
            '-definevars'        => sprintf(
                "listname='%s' hostname=%s yyyy=%s mois=%s yyyymm=%s-%s wdir=%s base=%s/arc tag=%s",
                $listname, $robot, $yyyy, $mm, $yyyy, $mm, $arcpath,
                Conf::get_robot_conf($robot, 'wwsympa_url'), $tag
            ),
            '-umask' => $Conf::Conf{'umask'}
        );

        Log::do_log('debug', 'System call: %s', join(' ', @cmd));

        my $savein;
        unless (open $savein, '<&STDIN' and open STDIN, '<', $output) {
            Log::do_log('err', 'Could not open %s: %s', $output, $!);
            return undef;
        }
        my $exitcode = system(@cmd) >> 8;
        open STDIN, '<&', $savein;

        # Delete temporary file containing escaped HTML.
        if ($output && -f $output) {
            unlink $output;
        }

        ## Remove lock if required
        if ($exitcode == 75) {
            Log::do_log(
                'notice',
                'Removing lock directory %s',
                $monthdir . '/.mhonarc.lck'
            );
            rmdir $monthdir . '/.mhonarc.lck';

            my $savein;
            unless (open $savein, '<&STDIN' and open STDIN, '<', $output) {
                Log::do_log('err', 'Could not open %s: %s', $output, $!);
                return undef;
            }
            $exitcode = system(@cmd) >> 8;
            open STDIN, '<&', $savein;
        }
        if ($exitcode) {
            Log::do_log(
                'err',
                'Command %s failed with exit code %s',
                join(' ', @cmd), $exitcode
            );
        }

        save_idx("$monthdir/index", $newfile);
    }
}

# Sets the value of $ENV{'M2H_ADDRESSMODIFYCODE'} and $ENV{'M2H_MODIFYBODYADDRESSES'}
#* $tag a character string (containing the result of get_tag($list))
sub set_hidden_mode {
    ## tag is used as variable elements in tags to prevent message contents to
    ## be parsed
    my $tag = shift;

    ## $ENV{'M2H_MODIFYBODYADDRESSES'} Ã  positionner si le corps du message est parse
    $ENV{'M2H_ADDRESSMODIFYCODE'} =
        "s|^([^\@]+)\@([^\@]+)\$|\($tag\%hidden_head\%$tag\)\$1\($tag\%hidden_at\%$tag\)\$2\($tag\%hidden_end\%$tag\)|g";
    $ENV{'M2H_MODIFYBODYADDRESSES'} = 1;
}

# Empties $ENV{'M2H_ADDRESSMODIFYCODE'}.
sub unset_hidden_mode {

    ## Be careful, the .mhonarc.db file keeps track of previous
    ## M2H_ADDRESSMODIFYCODE setup
    $ENV{'M2H_ADDRESSMODIFYCODE'} = '';
}

# Saves the archives index file
#* $index, a string corresponding to the file name to which save an index.
#* $lst, a character string
sub save_idx {
    my ($index, $lst) = @_;

    return unless $lst;

    open INDEXF, '>', $index
        or die sprintf 'Couldn\'t overwrite index %s: %s', $index, $!;
    print INDEXF "$lst\n";
    close INDEXF;
}

## Create the 'index' file for one archive subdir
sub create_idx {
    my $arc_dir = shift;    ## corresponds to the yyyy-mm directory

    my $arc_txt_dir = $arc_dir . '/arctxt';

    unless (opendir(DIR, $arc_txt_dir)) {
        Log::do_log('err', 'Failed to open directory "%s"', $arc_txt_dir);
        return undef;
    }

    my @files = (sort { $a <=> $b; } grep(/^\d+$/, (readdir DIR)));
    my $index = $files[$#files] || 0;
    save_idx($arc_dir . '/index', $index);

    closedir DIR;

    return $index;
}

# OBSOLETED.
# Use Sympa::Archive::get_tag().
sub get_tag {
    my $listname = shift;

    return (
        substr(
            Digest::MD5::md5_hex(join('/', $Conf::Conf{'cookie'}, $listname)),
            -10
        )
    );
}

# Checks if directory exists and we have write and read accec to it.
sub directory_check {
    my $dir = shift;
    unless (-d $dir) {
        printf STDERR "Creating missing %s directory\n", $dir;
        unless (mkdir $dir, 0775) {
            Log::do_log('err', 'Unable to create directory %s', $dir);
            return undef;
        }
        unless (
            tools::set_file_rights(
                file  => $dir,
                user  => Sympa::Constants::USER,
                group => Sympa::Constants::GROUP,
                mode  => 0775,
            )
            ) {
            Log::do_log('err', 'Unable to set rights on %s', $dir);
            return undef;
        }
    }
    unless ((-r $dir) && (-w $dir)) {
        Log::do_log('err', 'Unsufficient access to %s directory', $dir);
        return undef;
    }
    return 1;
}

__END__

=encoding utf-8

=head1 NAME

archived, archived.pl - Mailing List Archiving Daemon for Sympa

=head1 SYNOPSIS

S<B<archived.pl> [ B<--foreground> ] [ B<--debug> ]>

=head1 DESCRIPTION

B<Archived> is a program which scan permanently the outgoing B<Sympa> spool
and feeds the web archives, converting messages to the HTML format and
linking them. Original mails are also kept (in I<arctxt/> directory> for
later rebuilding of archives.

The HTML conversion is achieved by the means of the B<MHonArc> program.

Archives are accessed via B<wwsympa.fcgi> and B<sympa.pl>,
which proposes access control;
therefore archives should not be located in a public web directory.

=head1 OPTIONS

These programs follow the usual GNU command line syntax,
with long options starting with two dashes (`-').  A summary of
options is included below.

=over 5

=item B<-F>, B<--foreground>

Do not detach TTY.

=item B<-d>, B<--debug>

Run the program in a debug mode.

=item B<-h>, B<--help>

Print this help message.

=back

=head1 FILES

F<--spooldir--/outgoing/> outgoing Sympa directory.

F<--defaultdir--/mhonarc-ressources.tt2> template of MHonArc resource file.

F<--CONFIG--> Sympa configuration file.

F<--piddir--/archived.pid> this file contains the process ID
of F<archived.pl>.

=head1 MORE DOCUMENTATION

The full documentation in HTML and PDF formats can be found in
L<http://www.sympa.org/manual/>.

The mailing lists (with web archives) can be accessed at
L<http://listes.renater.fr/sympa/lists/informatique/sympa>.

=head1 HISTORY

This program was originally written by:

=over 4

=item Serge Aumont

ComitE<233> RE<233>seau des UniversitE<233>s

=item Olivier SalaE<252>n

ComitE<233> RE<233>seau des UniversitE<233>s

=back

This manual page was initially written by
JE<233>rE<244>me Marant <jerome.marant@IDEALX.org>
for the Debian GNU/Linux system.

=head1 LICENSE

You may distribute this software under the terms of the GNU General
Public License Version 2.  For more details see F<README> file.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts and no Back-Cover Texts.  A
copy of the license can be found under
L<http://www.gnu.org/licenses/fdl.html>.

=head1 BUGS

Report bugs to Sympa bug tracker.
See L<http://www.sympa.org/tracking>.

=head1 SEE ALSO

L<sympa(8)>, L<bounced(8)>, L<mhonarc(1)>, L<sympa.conf(5)>.

=cut
